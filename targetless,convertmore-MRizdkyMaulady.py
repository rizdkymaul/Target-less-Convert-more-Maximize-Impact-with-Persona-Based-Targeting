# -*- coding: utf-8 -*-
"""Mini_project1-MRizdkyMaulady.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wEDQ_2ZSGLE93V85tIZwPnWLQHCbM03H

# Predict Customer Personality to Boost Marketing Campaign by Using Machine Learning

- Name : Muhammad Rizdky Maulady

Overview
‚ÄúSebuah perusahaan dapat berkembang dengan pesat saat mengetahui perilaku customer personality nya, sehingga dapat memberikan layanan serta manfaat lebih baik kepada customers yang berpotensi menjadi loyal customers. Dengan mengolah data historical marketing campaign guna menaikkan performa dan menyasar customers yang tepat agar dapat bertransaksi di platform perusahaan, dari insight data tersebut fokus kita adalah membuat sebuah model prediksi kluster sehingga memudahkan perusahaan dalam membuat keputusan ‚Äù

##**Project Pipeline**

1. **Conversion Rate Analysisüìä**

Langkah pertama adalah mengevaluasi conversion rate untuk mengetahui seberapa efektif strategi marketing yang sudah berjalan. Dari sini, area-area yang masih perlu dioptimalkan bisa mulai teridentifikasi.

2. **Data Cleaning & Feature Engineeringüõ†Ô∏è**

Data dirapikan terlebih dahulu‚Äîmulai dari pembersihan fitur-fitur baru dikembangkan dari data yang tersedia agar model prediksi semakin akurat. Fokus diberikan pada variabel-variabel yang benar-benar mencerminkan perilaku dan karakter pelanggan.

3. **Data Preprocessingüßπ**

Sebelum masuk ke tahap machine learning, Handling Outlier, standarisasi format, hingga proses encoding. Tujuannya agar seluruh dataset siap digunakan secara konsisten.

4. **Modelingü§ñ**

Dengan data yang sudah siap pakai, model prediktif dibangun menggunakan algoritma machine learning. Proses training dan tuning dilakukan untuk mendapatkan hasil terbaik.

5. **Customer Personality analysis for Marketing Retargeting (Presona)**

Menganalisis hasil cluster dengan data yang kita punya untuk pembentukan persona martket campign target

6. **Calculate the Impactüìà**

Tahap akhir adalah mengukur dampak model terhadap campaign marketing. Peningkatan engagement pelanggan setelah implementasi model juga dievaluasi untuk melihat efektivitasnya.

# **1 : Conversion Rate Analysis Based On Income, Spending And Age**
Goals : Find a pattern of Customer behavior.<br><br>
Objective :
- Cleaning data
- Feature engineering
- Exploratory Data Analysis (EDA)  
- Analyze Conversion Rate with other variables such as age, income, expenses, etc
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_samples, silhouette_score
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import StandardScaler
from yellowbrick.cluster import KElbowVisualizer, SilhouetteVisualizer
from sklearn.decomposition import PCA
import warnings
warnings.filterwarnings('ignore')

"""marketing_campaign_data.csv

## **Load Data & Preliminary Analysis**
"""

from google.colab import drive
drive.mount('/content/drive')


file_path = '/content/drive/My Drive/marketing_campaign_data.csv'
df = pd.read_csv(file_path, low_memory=True)  # Meminimalkan penggunaan memori
df.columns = [col.lower() for col in df.columns]

df_simulation = df.copy()
df_analyst = df.copy()
df.head()

# split data by rows and columns
rows = df.shape[0]
cols = df.shape[1]

"""Data Understanding

Data Column Information:

    Unnamed: 0: An unnamed index or identifier column.
    ID: Customer identification number or code.
    Year_Birth: Year of birth of the customer.
    Education: The level of education attained by the customer.
    Marital_Status: Marital status of the customer.
    Income: Customer's income.
    Kidhome: Number of children in the household.
    Teenhome: Number of teenagers in the household.
    Dt_Customer: Date when the customer became a client.
    Recency: Number of days since the last purchase.
    MntCoke: Amount spent on Coke products.
    MntFruits: Amount spent on fruit products.
    MntMeatProducts: Amount spent on meat products.
    MntFishProducts: Amount spent on fish products.
    MntSweetProducts: Amount spent on sweet products.
    MntGoldProds: Amount spent on gold products.
    NumDealsPurchases: Number of purchases made with deals or discounts.
    NumWebPurchases: Number of purchases made through the web.
    NumCatalogPurchases: Number of purchases made from catalogs.
    NumStorePurchases: Number of purchases made in physical stores.
    NumWebVisitsMonth: Number of web visits per month.
    AcceptedCmp3: Whether the customer accepted Campaign 3 (binary, likely a marketing campaign).
    AcceptedCmp4: Whether the customer accepted Campaign 4 (binary, likely a marketing campaign).
    AcceptedCmp5: Whether the customer accepted Campaign 5 (binary, likely a marketing campaign).
    AcceptedCmp1: Whether the customer accepted Campaign 1 (binary, likely a marketing campaign).
    AcceptedCmp2: Whether the customer accepted Campaign 2 (binary, likely a marketing campaign).
    Complain: Whether the customer has registered a complaint (binary).
    Z_CostContact: Cost of contacting the customer.
    Z_Revenue: Revenue generated from the customer.
    Response: Customer response to a marketing campaign (binary, likely indicating whether they responded positively to a campaign).

"""

df_analyst

# Display the information about the DataFrame
print("DataFrame Information:")
df_analyst.info()

pd.set_option('display.max_columns', None)

# Pilih kolom-kolom bertipe objek dan simpan dalam variabel 'categoric'
categoric = df.select_dtypes('object')

# Pilih kolom-kolom bertipe numerik dan simpan dalam variabel 'numeric'
numeric = df.select_dtypes('number')

# Tentukan jumlah baris dan kolom
rows = df.shape[0]
cols = df.shape[1]

# Cetak bentuk DataFrame
print(f'Jumlah Baris: {rows}\nJumlah Kolom: {cols}')

# Cetak sampel 6 baris dari DataFrame
print('\nContoh Data:')
display(df.sample(6))

# Cetak ringkasan statistik data kategorikal
print('\nRingkasan Statistik Data Kategorikal:')
display(categoric.describe())

# Cetak ringkasan statistik data numerik
print('\nRingkasan Statistik Data Numerik:')
display(numeric.describe())

# Define categorical_col and numerical_col before printing
categorical_col = categoric.columns.tolist()  # Get the list of categorical columns
numerical_col = numeric.columns.tolist()    # Get the list of numerical columns

print("Categorical columns: ", categorical_col)
print("Numerical columns: ", numerical_col)

for cols in categorical_col:
  print(f"Categories in {cols}:", df[cols].unique())

# Memampilkan isi value dalam setiap kolom
print('\nNumerical data value counts:')
for col in numeric.columns:
    print(f'{col} value counts: ')
    print(numeric[col].value_counts())
    print('=-='*5)

df.describe().T

"""## **Statistics Summary**

Customer marketing campaign data
*  Contains 30 columns (26 integer, 1 float, and 3 object types)
*  Total of 2,240 rows
*  Contains 1 column with date/time values (Dt_Customer)
*  Total of 3 categorical features (Education, Marital_Status, Dt_Customer)
*  Total of 27 numerical features (integer and float types)

**1. Ringkasan Statistik**

* Dataset memiliki beberapa kolom numerik dengan rentang nilai yang sangat luas, terutama pada kolom seperti Income, MntMeatProducts, dan MntCoke, menunjukkan adanya distribusi yang tidak normal dan kemungkinan outlier.

* Perbedaan mencolok antara nilai rata-rata (mean) dan median pada beberapa kolom menunjukkan adanya skewness.

* Terdapat juga kolom dengan nilai maksimal yang sangat ekstrem dibanding kuartil atas, seperti Income (maksimum 666 juta vs Q3 sekitar 68 juta), yang mengindikasikan keberadaan outlier ekstrem.

**2. Kolom dengan High Cardinality**

Kolom-kolom berikut memiliki jumlah nilai unik yang sangat tinggi:

* ID Pelanggan / ID Transaksi (jika ada): Biasanya tiap baris unik dan tidak berguna untuk analisis langsung.

* Dt_Customer: Nilai tanggal yang sangat beragam dan granular.

üö© Tindakan: Kolom-kolom ini dapat dihapus atau dikategorikan ulang (misalnya menjadi tahun atau bulan) untuk efisiensi analisis.

**3. Kolom dengan Imbalance Data (Ketidakseimbangan Data)**

* Beberapa kolom seperti Response, AcceptedCmp1 hingga AcceptedCmp5, dan Complain menunjukkan distribusi tidak seimbang (mayoritas nilai 0).

üö© Tindakan: Jika lebih dari 95‚Äì99% isinya bernilai sama, kolom bisa dipertimbangkan untuk dihapus karena tidak banyak kontribusi terhadap pemodelan.

**4. Kolom dengan Variasi Rendah**

* Kolom seperti Z_CostContact dan Z_Revenue hanya memiliki satu nilai unik di seluruh dataset.

üö© Tindakan: Bisa dihapus karena tidak memberikan informasi apapun dalam proses analisis atau prediksi.

**5. Korelasi Antar Variabel**

* Beberapa kolom pengeluaran (MntMeatProducts, MntFishProducts, dll) kemungkinan memiliki korelasi tinggi karena berhubungan dengan total spending.

üö© Tindakan: Analisis korelasi lebih lanjut perlu dilakukan untuk menghindari multikolinearitas, dan memungkinkan penggabungan menjadi total belanja.

**6. Missing Values (Data Kosong)**

* Terdapat nilai kosong pada kolom Income dan Dt_Customer.

üö© Tindakan: Jika jumlah data kosong masih proporsional, bisa dilakukan imputasi (median untuk Income, drop untuk Dt_Customer jika tidak terlalu penting). Jika >50%, kolom bisa dihapus.

**7. Distribusi Kategori**

* Kolom seperti Education, Marital_Status, dan Country memiliki distribusi yang tidak seimbang.

üö© Tindakan: Untuk hasil analisis yang lebih representatif, bisa dilakukan penggabungan kategori (misal, menyatukan status pernikahan menjadi ‚ÄúSingle‚Äù dan ‚ÄúNot Single‚Äù).

## **Check Duplicated & Missing Value**

### **Handling Missing Value**
"""

dfe = df.copy()
# Memeriksa baris duplikat
duplicate_rows = dfe.duplicated()

# Menampilkan jumlah baris duplikat
print(f"Jumlah baris duplikat: {duplicate_rows.sum()}")

# Fungsi untuk menghitung dan menampilkan kolom dengan nilai missing
def check_nan(dfe):
    # Hitung nilai null
    null_values = dfe.isnull().sum()

    # Buat DataFrame untuk total nilai null dan persentase
    nvc = pd.DataFrame(null_values[null_values > 0].sort_values(), columns=['Total Null Values'])  # Hanya ambil kolom dengan nilai null
    nvc['Percentage'] = (nvc['Total Null Values'] / dfe.shape[0]) * 100
    nvc["Data Type"] = [dfe[col].dtype for col in nvc.index]  # Ambil tipe data dari kolom yang ada

    # Urutkan berdasarkan total nilai null dan persentase
    nvc.sort_values(by=["Total Null Values", "Percentage"], ascending=False, inplace=True)

    # Tampilkan hasil dengan gaya
    return nvc.style.background_gradient(cmap='Blues')

# Panggil fungsi dan simpan hasilnya
styled_result = check_nan(dfe)

# Untuk menampilkan hasil di Jupyter Notebook, gunakan:
styled_result

"""1. income ‚Äì Missing 1.07%,  diisi dengan median karena distribusinya sangat skewed ke kanan, untuk menghindari distorsi akibat outlier."""

# Isi missing value pada kolom 'income' dengan median
median_income = dfe['income'].median()
dfe['income'].fillna(median_income, inplace=True)

# recheck missing values
check_nan(dfe)

# Print count Infiinity values in dataframe
count_inf = dfe.map(lambda x: isinstance(x, float) and x == float('inf')).sum().sum()
print(f"Count of Infinity Values :\nIt Contains {str(count_inf)} Infinite values in dataframe")

# print column where infinity values exist
col_inf = dfe.columns[dfe.map(lambda x: isinstance(x, float) and x == float('inf')).any()]
print("\nColumns where Infinity values exist:")
print(", ".join(col_inf))

"""## **Feature Engineering**

### **Create New Features**

#### **Age & Age Group**

Age: Fitur ini merepresentasikan usia dari setiap pelanggan, yang diperoleh dengan mengurangkan tahun saat ini dengan nilai pada kolom Year_Birth.
"""

dfe['age'] = 2025 - dfe['year_birth']

import matplotlib.pyplot as plt
plt.figure(figsize=(10, 6))
sns.histplot(dfe['age'], bins=20, kde=True)  # Adjust bins as needed
plt.title('Distribution of Age')
plt.xlabel('age')
plt.ylabel('Frequency')
plt.show()

dfe.describe().T

"""Terlihat bahwa adanya umur yang tidak normal yaitu dengan konsumen yang memounyai umur 132 tahun, Namun dalam kasus ini akan tetap saya simpan dengan kemungkinan akun digunakan oleh keluarganya."""

# Mengelompokkan pelanggan ke dalam kategori umur
# Young Adults: usia 28‚Äì39, Middle-aged Adults: usia 40‚Äì59, Old Adults: usia 60 ke atas
age_grouping = [
    (dfe['age'] >= 60),
    (dfe['age'] >= 40) & (dfe['age'] < 60),
    (dfe['age'] >= 28) & (dfe['age'] < 40)
]
age_category = ['Old Adults', 'Middled-aged Adults', 'Young Adults']
# Explicitly set the default value to an empty string to match the type of age_category
dfe['age_group'] = np.select(age_grouping, age_category, default='')

plt.figure(figsize=(10, 6))
sns.histplot(dfe['age_group'], bins=20, kde=True)  # Adjust bins as needed
plt.title('Distribution of age_group')
plt.xlabel('age_grouping')
plt.ylabel('Frequency')
plt.show()

"""#### **Total Children**

Jumlah anak yang dihitung dari kolom Kidhome (jumlah anak di rumah) dan Teenhome (jumlah remaja di rumah).
"""

dfe['total_children'] = dfe['kidhome'] + dfe['teenhome']

"""#### **Total Spent**
Total pengeluaran customer untuk berbagai produk seperti Coke, Fish Products, Fruits, dll.
"""

dfe['total_spent'] = dfe[['mntcoke', 'mntfishproducts', 'mntfruits', 'mntmeatproducts', 'mntsweetproducts', 'mntgoldprods']].sum(axis=1)

"""#### **Total Purchases**
Total transaksi yang dilakukan oleh customer melalui berbagai channel (deals, web, catalog, store).
"""

dfe['total_purchases'] = dfe[['numdealspurchases', 'numwebpurchases', 'numcatalogpurchases', 'numstorepurchases']].sum(axis=1)

"""#### **Total Responses**
Total respon customer terhadap kampanye (AcceptedCmp1, AcceptedCmp2, dll.)
"""

dfe['total_responses'] = dfe[['acceptedcmp1', 'acceptedcmp2', 'acceptedcmp3', 'acceptedcmp4', 'acceptedcmp5', 'response']].sum(axis=1)

"""#### **Conversion Rate**
Rasio konversi dihitung berdasarkan Total Respon terhadap jumlah web visits.
"""

def safe_div(x, y):
    return 0 if y == 0 else x / y

dfe['conversion_rate'] = dfe.apply(lambda x: safe_div(x['total_responses'], x['numwebvisitsmonth']), axis=1)

"""#### **Tenure Days & Tenure Group**
Tenure (lama waktu berlangganan) customer dihitung berdasarkan tanggal pertama kali mereka mendaftar.
"""

print(dfe['dt_customer'].head())

dfe['dt_customer'] = pd.to_datetime(dfe['dt_customer'], format='%d-%m-%Y') # Changed the format to day-month-year
dfe['tenure_days'] = (pd.to_datetime('2025-01-01') - dfe['dt_customer']).dt.days

dfe['tenure_group'] = pd.qcut(dfe['tenure_days'], q=5, labels=['Very Short', 'Short', 'Medium', 'Long', 'Very Long'])

"""#### **Income Level**
Kategori penghasilan customer berdasarkan bin yang telah didefinisikan (Low, Moderate, High, Very High).
"""

dfe['income'].describe()

income_bins = [0, 35000000, 51000000, 70000000, np.inf]
income_labels = ['Low Income', 'Moderate Income', 'High Income', 'Very High Income']
dfe['income_level'] = pd.cut(dfe['income'], bins=income_bins, labels=income_labels, include_lowest=True)

"""#### **Recency Group**
Kelompokkan customer berdasarkan recency mereka (Recent, Moderate, Less Recent, Inactive).
"""

dfe['recency'].describe()

recency_bins = [0, 30, 60, 90, 100]
recency_labels = ['Recent', 'Moderate', 'Less Recent', 'Inactive']
dfe['recency_group'] = pd.cut(dfe['recency'], bins=recency_bins, labels=recency_labels, include_lowest=True)

"""#### **Channel Preference**

"""

def most_used_channel(row):
    channels = {
        'Web': row['numwebpurchases'],
        'Catalog': row['numcatalogpurchases'],
        'Store': row['numstorepurchases']
    }
    return max(channels, key=channels.get)

dfe['channel_preference'] = dfe.apply(most_used_channel, axis=1)

categorical_col_dfe = dfe.select_dtypes(include=['object', 'category']).columns.tolist()
numerical_col_dfe = dfe.select_dtypes(include=['number']).columns.tolist()

print("Categorical columns: ", categorical_col_dfe)
print("Numerical columns: ", numerical_col_dfe)

# recheck missing values
check_nan(dfe)

print(dfe['total_responses'].unique())

display(dfe[['id','age', 'age_group', 'total_children', 'total_spent', 'total_purchases', 'total_responses', 'conversion_rate', 'tenure_days','tenure_group', 'income_level', 'recency_group', 'channel_preference']].head())

"""## **EDA**

### **Univariate Analysis**

#### **Outlier Check**
"""

# Get numerical columns from the DataFrame 'df'
num_columns = dfe.select_dtypes(include=['number']).columns

# Now you can use 'num_columns' as intended
num_columns # numerical columns

import matplotlib.pyplot as plt
import seaborn as sns
import math

def plot_outliers(dfe, num_cols, cols_per_row=4, row_height=4, col_width=5):
    total = len(num_cols)
    rows = math.ceil(total / cols_per_row)
    figsize = (col_width * cols_per_row, row_height * rows)

    plt.style.use('default')  # Background putih
    fig, axes = plt.subplots(rows, cols_per_row, figsize=figsize)
    axes = axes.flatten()

    for i, col in enumerate(num_cols):
        sns.boxplot(y=dfe[col], ax=axes[i], color='steelblue', linewidth=1)
        axes[i].set_title(f'{col}', fontsize=10)
        axes[i].set_ylabel('')
        axes[i].grid(True, linestyle='--', alpha=0.5)

    # Hapus subplot kosong
    for j in range(i + 1, len(axes)):
        fig.delaxes(axes[j])

    plt.tight_layout()
    plt.suptitle('Boxplots of Numerical Features', fontsize=14, y=1.02)
    plt.show()

dfe

# function call
plot_outliers(dfe, num_columns)

def outliers_info(series):
    Q1 = series.quantile(0.25)
    Q3 = series.quantile(0.75)
    IQR = Q3 - Q1
    upper_bound = Q3 + 1.5 * IQR
    lower_bound = Q1 - 1.5 * IQR

    count = ((series < lower_bound) | (series > upper_bound)).sum()
    return count, upper_bound, lower_bound

def print_outliers(dfe, num_cols):
    outliers_dict = {}  # store the column name and the number of outliers present

    for col in num_cols:
        count, upper, lower = outliers_info(dfe[col])  # gunakan variabel baru

        if count > 0:
            outliers_dict[col] = count  # simpan hanya kolom yang punya outlier

    # Sort hasilnya dari yang paling banyak outlier
    sorted_outliers = dict(sorted(outliers_dict.items(), key=lambda item: item[1], reverse=True))

    # Tampilkan
    for col, val in sorted_outliers.items():
        print(f'Total outliers in {col}: {val} ({((val/len(df)) * 100):.2f}%)')

    print(f'\nTotal columns with outliers: {len(sorted_outliers)} out of {len(num_cols)}')

print_outliers(dfe, num_columns)

"""* Outlier yang tinggi seperti pada kolom TotalAcceptedCmp, Response, dan

* pengeluaran untuk produk tertentu bisa menunjukkan adanya perbedaan yang signifikan dalam perilaku pelanggan yang perlu dianalisis lebih lanjut.

* Outlier pada kampanye dan pembelian dapat menunjukkan adanya pelanggan dengan tingkat keterlibatan yang sangat tinggi, yang perlu dianalisis lebih lanjut apakah ini wajar atau ada masalah dalam data.

* Outlier yang rendah pada kolom seperti Income, Year_Birth, dan NumWebVisitsMonth menunjukkan data yang cukup homogen, namun tetap ada beberapa nilai ekstrem yang perlu diperhatikan, meskipun jumlahnya sangat kecil.

**Tindakan yang bisa diambil:**

* Menghapus outlier: Jika outlier tidak relevan atau diduga merupakan kesalahan data, bisa dipertimbangkan untuk menghapusnya.

* Transformasi data: Menggunakan teknik transformasi data seperti log-transformation untuk mereduksi pengaruh outlier pada model prediktif.

* Penyelidikan lebih lanjut: Untuk outlier yang masuk akal, bisa menjadi wawasan untuk mengidentifikasi pelanggan yang memiliki perilaku berbeda, seperti pelanggan yang sangat responsif terhadap kampanye atau pelanggan dengan pengeluaran yang sangat tinggi.

#### **Data Distribution Numeric & Categoric**
"""

from scipy.stats import skew, kurtosis
import pandas as pd

num_cols = dfe.select_dtypes(include=np.number).columns.tolist()

skew_type_list = []
skew_val_list = []
kurtosis_val_list = []

for column in num_cols:
    data = dfe[column].dropna(axis=0)
    mean = round(data.mean(), 3)
    median = data.median()
    mode = data.mode()[0]
    skew_val = round(skew(data, nan_policy="omit"), 3)
    kurtosis_val = round(kurtosis(data, nan_policy="omit"), 3)

    if (mean == median == mode) or (-0.2 < skew_val < 0.2):
        skew_type = "Normal Distribution (Symmetric)"
    elif mean < median < mode:
        skew_type = "Negatively Skewed"
        if skew_val <= -1:
            skew_type = "Highly Negatively Skewed"
        elif -0.5 >= skew_val > -1:
            skew_type = "Moderately Negatively Skewed"
        else:
            skew_type = "Moderately Normal Distribution (Symmetric)"
    else:
        skew_type = "Positively Skewed"
        if skew_val >= 1:
            skew_type = "Highly Positively Skewed"
        elif 0.5 <= skew_val < 1:
            skew_type = "Moderately Positively Skewed"
        else:
            skew_type = "Moderately Normal Distribution (Symmetric)"

    skew_type_list.append(skew_type)
    skew_val_list.append(skew_val)
    kurtosis_val_list.append(kurtosis_val)

dist = pd.DataFrame({
    "Column Name": num_cols,
    "Skewness": skew_val_list,
    "Kurtosis": kurtosis_val_list,
    "Type of Distribution": skew_type_list
})

dist = dist.sort_values(["Type of Distribution", "Column Name"]).reset_index(drop=True)
dist

"""  	Total Null Values 	Percentage 	Data Type
income_level 	383 	17.098214 	object
recency_group 	28 	1.250000 	int64
income 	24 	1.071429 	int64
"""

# Menentukan ukuran figure
plt.figure(figsize=(15, 17))

numeric_filtered = dfe.select_dtypes(include=np.number)  # Define numeric_filtered here

# Menentukan jumlah plot yang akan dibuat
num_plots = len(numeric_filtered.columns)  # Pastikan 'numeric_filtered' berisi kolom numerik
num_rows = (num_plots + 2) // 3  # Menyesuaikan dengan jumlah kolom per baris

# Looping untuk membuat histogram + KDE plot per kolom
for index, column in enumerate(numeric_filtered.columns):
    plt.subplot(num_rows, 3, index + 1)  # Mengatur jumlah baris dan kolom
    plt.subplots_adjust(wspace=0.3, hspace=0.5)  # Menyesuaikan jarak antar plot

    # Membuat histogram dengan KDE
    sns.histplot(numeric_filtered[column], kde=True, color="royalblue", bins=30)

    # Mengatur judul dan label
    plt.title(column, fontsize=14)
    plt.xlabel(column.upper(), fontsize=12)
    plt.ylabel("Count", fontsize=12)

# Menyesuaikan tata letak plot
plt.tight_layout(pad=1.0)

# Menampilkan plot
plt.show()

"""### **Multivariate Analysis**"""

import matplotlib.pyplot as plt
import seaborn as sns

# Ambil hanya kolom numerik
numeric_cols = dfe.select_dtypes(include='number')

# Hitung korelasi semua fitur numerik terhadap ConversionRate
corr_with_conversion = numeric_cols.corr()['conversion_rate'].drop('conversion_rate').sort_values(key=abs, ascending=False)

# Plot korelasi dalam bentuk barplot
plt.figure(figsize=(12, 8))
sns.barplot(x=corr_with_conversion.values, y=corr_with_conversion.index, palette='coolwarm')

plt.title('Correlation of Numerical Features with Conversion Rate', fontsize=16)
plt.xlabel('Correlation')
plt.ylabel('Feature')
plt.grid(True, linestyle='--', alpha=0.5)
plt.axvline(x=0, color='gray', linestyle='--')
plt.tight_layout()
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

# Ambil hanya kolom numerik
numeric_dfe = dfe.select_dtypes(include=np.number)

# Hitung korelasi
corr_matrix = numeric_dfe.corr()

# Buat heatmap
plt.figure(figsize=(16, 12))
sns.heatmap(corr_matrix, annot=True, fmt=".2f", cmap="coolwarm", linewidths=0.5, square=True)

# Judul dan tampilan
plt.title("Heatmap Korelasi Antar Fitur Numerik", fontsize=20, fontweight='bold')
plt.xticks(rotation=45, ha='right')
plt.yticks(rotation=0)
plt.tight_layout()

plt.show()

"""Berikut kolom yang bisa dihapus (pilihan optimal untuk clustering):

year_birth ‚Üí sudah ada age

response ‚Üí sudah tercakup di total_responses

total_purchases ‚Üí sudah terwakili oleh komponen numwebpurchases, numstorepurchases, dst

mntmeatproducts ‚Üí jika sudah ada mntgoldproducts, mntfishproducts, mntsweetproducts, dst

numcatalogpurchases atau numstorepurchases ‚Üí jika terlalu mirip, pilih salah satu

total_spent ‚Üí opsional hapus jika semua mnt*products masih digunakan

Fitur 1	Fitur 2	Korelasi	Catatan
year_birth	age	-1.00	Pilih salah satu, simpan age
response	total_responses	0.95	Simpan salah satu, total_responses cukup
total_spent	mntmeatproducts	0.84	Bisa pertimbangkan hapus salah satunya
total_purchases	numstorepurchases	0.84	Hati-hati, bisa drop total_purchases jika semua channel ada
conversion_rate	response	0.70	Masih aman, tidak perlu dihapus
mntsweetproducts	mntmeatproducts	0.86	Hapus salah satu jika fokusnya efisiensi
mntfishproducts	mntmeatproducts	0.85	Mirip seperti di atas
"""

# Ambil hanya kolom numerik dari data lo
numeric_dfe = dfe.select_dtypes(include=np.number)

# Hitung korelasi antar fitur numerik
num_corr = numeric_dfe.corr()

# Filter korelasi signifikan > 0.85 tapi < 1.0 (biar gak include diagonal 1.0)
filtered_corr = num_corr.where((num_corr > 0.85) & (num_corr < 1.0))

# Plot heatmap korelasi yang sudah difilter
plt.figure(figsize=(15, 11))
sns.heatmap(filtered_corr, annot=True, cmap='coolwarm', mask=filtered_corr.isnull(), linewidths=0.5)
plt.title('Filtered Correlation Matrix (> 0.85)', fontsize=20, fontweight='bold')
plt.xticks(rotation=45, ha='right')
plt.yticks(rotation=0)
plt.tight_layout()
plt.show()

"""### **Analysis Data & Business Insight**"""

# Biaya campaign per customer
cost_per_customer = 50000  # Rp

# Hitung jumlah customer
total_customers_before = len(dfe)

# Hitung rata-rata conversion rate & total spending
conversion_rate_before = dfe['conversion_rate'].mean()
avg_spending_before = dfe['total_spent'].mean()

# Hitung total revenue dan cost
total_revenue_before = conversion_rate_before * avg_spending_before * total_customers_before
total_cost_before = total_customers_before * cost_per_customer
roi_before = (total_revenue_before - total_cost_before) / total_cost_before

# --- Visualisasi Revenue vs Cost ---
labels = ['Revenue', 'Cost']
values = [total_revenue_before, total_cost_before]
colors = ['#e95420', '#a8a8a8']  # Oranye & abu-abu dari slide

plt.figure(figsize=(8, 5))

bars = plt.bar(labels, values, color=colors)

# Label nilai
for bar in bars:
    yval = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2, yval + 2e6, f'Rp {yval/1e6:.1f}M',
             ha='center', va='bottom', fontsize=12)

plt.title('Problem Statement: Revenue vs Cost', fontsize=14)
plt.ylabel('Amount (Rp)')

plt.grid(False)  #
ax = plt.gca()
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
plt.tight_layout()
plt.show()

# --- Visualisasi Conversion Rate Donut Chart ---
converted = conversion_rate_before
not_converted = 1 - converted
sizes = [converted, not_converted]
labels = [f'Converted ({converted*100:.1f}%)', f'Not Converted ({not_converted*100:.1f}%)']
colors = ['#f5c518', '#f7f7f7']  # Kuning & putih

explode = (0.1, 0)

plt.figure(figsize=(6, 6))
wedges, texts, autotexts = plt.pie(sizes,
                                   labels=labels,
                                   colors=colors,
                                   startangle=90,
                                   autopct='%1.1f%%',
                                   explode=explode,
                                   textprops={'fontsize': 12})

centre_circle = plt.Circle((0,0),0.70,fc='white')
plt.gca().add_artist(centre_circle)

plt.title('Customer Conversion Rate', fontsize=14)
plt.tight_layout()
plt.show()

"""#### **Customer Demographics**

1. Conversion Rate vs Age Group
2. Conversion Rate vs Education
"""

# Palet warna yang disesuaikan dengan slide presentasi
custom_palette = ['#F26419', '#F6AE2D', '#2F2F2F', '#EDEDED']  # oranye, kuning, abu gelap, abu terang

# Mengatur ukuran figure
fig, axes = plt.subplots(1, 2, figsize=(18, 6))

# Subplot 1: Conversion Rate by Age Group
sns.barplot(data=dfe, x='age_group', y='conversion_rate', palette=custom_palette, ax=axes[0])
axes[0].set_title('Conversion Rate by Age Group', fontsize=14, fontweight='bold')
axes[0].set_xlabel('Age Group', fontsize=12)
axes[0].set_ylabel('Conversion Rate', fontsize=12)
axes[0].set_xticklabels(axes[0].get_xticklabels(), rotation=0)
axes[0].grid(False)  # Menghilangkan grid

# Menampilkan label nilai di atas tiap bar
for p in axes[0].patches:
    height = p.get_height()
    axes[0].annotate(f'{height:.2%}',
                     (p.get_x() + p.get_width() / 2., height),
                     ha='center', va='bottom', fontsize=11, fontweight='bold')

# Subplot 2: Education Level vs Conversion Rate
sns.barplot(data=dfe, x='education', y='conversion_rate', palette=custom_palette, ax=axes[1])
axes[1].set_title('Conversion Rate by Education Level', fontsize=14, fontweight='bold')
axes[1].set_xlabel('Education', fontsize=12)
axes[1].set_ylabel('Conversion Rate', fontsize=12)
axes[1].set_xticklabels(axes[1].get_xticklabels(), rotation=30)
axes[1].grid(False)  # Menghilangkan grid

# Menampilkan label nilai di atas tiap bar
for p in axes[1].patches:
    height = p.get_height()
    axes[1].annotate(f'{height:.2%}',
                     (p.get_x() + p.get_width() / 2., height),
                     ha='center', va='bottom', fontsize=11, fontweight='bold')

# Menyusun layout agar tidak tumpang tindih
plt.tight_layout()

# Menampilkan plot
plt.show()

"""#### **Household Insight**

1. Marital Status vs Conversion Rate
2. Total Children vs Conversion Rate
"""

# Palet warna disesuaikan dengan presentasi
custom_palette = ['#F26419', '#F6AE2D', '#2F2F2F', '#EDEDED']

# Ukuran gambar
plt.figure(figsize=(10, 6))

# Plot tunggal
sns.barplot(
    data=dfe,
    x='marital_status',
    y='conversion_rate',
    hue='total_children',
    palette=custom_palette
)

# Pengaturan tampilan
plt.title('Marital Status vs Conversion Rate by Total Children', fontsize=14, fontweight='bold')
plt.xlabel('Marital Status', fontsize=12)
plt.ylabel('Conversion Rate', fontsize=12)
plt.xticks(rotation=5)
plt.grid(False)
plt.legend(title='Total Children', fontsize=10, title_fontsize=11)

# Tampilkan plot
plt.tight_layout()
plt.show()

"""#### **Income & Spending**

**Income Level vs Conversion Rate**
"""

import matplotlib.pyplot as plt
import seaborn as sns

# Palet warna yang konsisten
custom_palette = ['#F26419', '#F6AE2D', '#2F2F2F', '#EDEDED']

# Plot
plt.figure(figsize=(10, 6))
ax = sns.barplot(data=dfe, x='income_level', y='conversion_rate', palette=custom_palette)
ax.set_title('Income Level vs Conversion Rate', fontsize=14, fontweight='bold')
ax.set_xlabel('Income Level', fontsize=12)
ax.set_ylabel('Conversion Rate', fontsize=12)
ax.tick_params(axis='x', rotation=0)
ax.grid(False)

# Menambahkan label persentase pada setiap bar
for p in ax.patches:
    height = p.get_height()
    ax.annotate(f'{height:.2%}',
                (p.get_x() + p.get_width() / 2., height),
                ha='center', va='bottom', fontsize=11, fontweight='bold')

plt.tight_layout()
plt.show()

"""**Total Spent vs Total Purchases**"""

plt.figure(figsize=(10,6))
sns.scatterplot(data=dfe, x='total_spent', y='total_purchases', hue='income_level', alpha=0.7, palette='Set2')
plt.title('Total Spent vs Total Purchases')
plt.xlabel('Total Spent')
plt.ylabel('Total Purchases')
plt.tight_layout()
plt.show()

"""### **Top Favorite Products**"""

# Menjumlahkan pembelian produk untuk setiap pengguna
product_columns = ['mntcoke', 'mntfruits', 'mntmeatproducts', 'mntfishproducts', 'mntsweetproducts', 'mntgoldprods']
dfe['total_product_spent'] = dfe[product_columns].sum(axis=1)

# Menghitung rata-rata pembelian untuk setiap kategori produk
avg_product_purchase = dfe[product_columns].mean()

# Membuat DataFrame untuk visualisasi
product_data = pd.DataFrame(avg_product_purchase).reset_index()
product_data.columns = ['Product Category', 'Average Purchase']
product_data = product_data.sort_values(by='Average Purchase', ascending=False)

# Custom palette sesuai dengan slide
custom_palette = ['#F26419', '#F6AE2D', '#2F2F2F', '#EDEDED', '#86BBD8', '#33658A']

# Visualisasi
plt.figure(figsize=(10, 6))
ax = sns.barplot(data=product_data, x='Average Purchase', y='Product Category', palette=custom_palette)
plt.title('Top Favorite Products Based on Average Purchase', fontsize=14, fontweight='bold')
plt.xlabel('Average Purchase (Rupiah)', fontsize=12)
plt.ylabel('Product Category', fontsize=12)
ax.grid(False)

# Menambahkan label nilai dalam format Rupiah pada setiap bar
for p in ax.patches:
    width = p.get_width()
    label = f'Rp {int(width):,}'.replace(',', '.')
    ax.text(width + 3, p.get_y() + p.get_height() / 2,
            label, ha='left', va='center', fontsize=11, fontweight='bold')

plt.tight_layout()
plt.show()

product_data.to_excel('avg_product_purchase.xlsx', index=False)

"""**Product Category vs Conversion Rate**"""

# Create a new column for total spent across product categories
dfe['total_product_spent'] = dfe[product_columns].sum(axis=1)

# Step 2: Calculate the average conversion rate for each category
category_conversion = []

for column in product_columns:
    category_avg = dfe.groupby(column)['conversion_rate'].mean().reset_index()
    category_avg['Product Category'] = column
    category_conversion.append(category_avg[['Product Category', 'conversion_rate']])

# Combine all category data
product_data = pd.concat(category_conversion)

# Step 3: Calculate the average conversion rate per category
avg_conversion_rate = product_data.groupby('Product Category')['conversion_rate'].mean().reset_index()
avg_conversion_rate = avg_conversion_rate.sort_values(by='conversion_rate', ascending=False)

# Custom palette sesuai dengan slide
custom_palette = ['#F26419', '#F6AE2D', '#2F2F2F', '#EDEDED', '#86BBD8', '#33658A']

# Step 4: Visualization
plt.figure(figsize=(10, 6))
ax = sns.barplot(data=avg_conversion_rate, x='conversion_rate', y='Product Category', palette=custom_palette)
plt.title('Product Category vs Conversion Rate', fontsize=14, fontweight='bold')
plt.xlabel('Average Conversion Rate', fontsize=12)
plt.ylabel('Product Category', fontsize=12)
ax.grid(False)

# Menambahkan label persentase pada setiap bar
for p in ax.patches:
    width = p.get_width()
    label = f'{width:.2%}'
    ax.text(width + 0.002, p.get_y() + p.get_height() / 2,
            label, ha='left', va='center', fontsize=11, fontweight='bold')

plt.tight_layout()
plt.show()

"""#### **Engagement & Journey**

**Tenure Group vs Total Purchases**
"""

# Palet warna sesuai slide
custom_palette = ['#F26419', '#F6AE2D', '#2F2F2F', '#EDEDED', '#86BBD8', '#33658A']

# Mengatur ukuran figure
plt.figure(figsize=(10, 6))

# Membuat bar plot dengan rata-rata conversion rate per tenure group
ax = sns.barplot(data=dfe, x='tenure_group', y='conversion_rate', palette=custom_palette)

# Menambahkan judul dan label sumbu
plt.title('Tenure Group vs Conversion Rate', fontsize=14, fontweight='bold')
plt.xlabel('Tenure Group', fontsize=12)
plt.ylabel('Conversion Rate', fontsize=12)
ax.grid(False)

# Menambahkan label nilai persentase pada setiap bar
for p in ax.patches:
    height = p.get_height()
    label = f'{height:.2%}'
    ax.text(p.get_x() + p.get_width() / 2, height + 0.002,
            label, ha='center', va='bottom', fontsize=11, fontweight='bold')

# Menyusun layout agar tidak tumpang tindih
plt.tight_layout()

# Menampilkan plot
plt.show()

# Palet warna sesuai slide
custom_palette = ['#F26419', '#F6AE2D', '#2F2F2F', '#EDEDED', '#86BBD8', '#33658A']

# Mengatur ukuran figure
plt.figure(figsize=(10, 6))

# Membuat bar plot dengan rata-rata conversion rate per recency group
ax = sns.barplot(data=dfe, x='recency_group', y='conversion_rate', palette=custom_palette, ci=None)

# Menambahkan judul dan label sumbu
plt.title('Recency Group vs Conversion Rate', fontsize=14, fontweight='bold')
plt.xlabel('Recency Group', fontsize=12)
plt.ylabel('Conversion Rate', fontsize=12)
ax.grid(False)

# Menambahkan label nilai persentase di atas setiap bar
for p in ax.patches:
    height = p.get_height()
    label = f'{height:.2%}'
    ax.text(p.get_x() + p.get_width() / 2, height + 0.002,
            label, ha='center', va='bottom', fontsize=11, fontweight='bold')

# Menyusun layout agar tidak tumpang tindih
plt.tight_layout()

# Menampilkan plot
plt.show()

"""#### **Preference & Behavior**

**Channel Preference Distribution**
"""

plt.figure(figsize=(10,6))
sns.barplot(data=dfe, x='channel_preference', y='conversion_rate', palette='Set2')
plt.title(' Conversion Rate by Channel')
plt.xlabel('Channel Preference')
plt.ylabel('Conversion Rate')
plt.tight_layout()
plt.show()

"""#### **Campaign Effectiveness**"""

import matplotlib.pyplot as plt
import seaborn as sns

# Data untuk visualisasi
campaign_cols = ['acceptedcmp1', 'acceptedcmp2', 'acceptedcmp3', 'acceptedcmp4', 'acceptedcmp5']
cmp_sum = dfe[campaign_cols].sum()

# Buat subplots
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Subplot 1: Channel Preference Distribution
sns.countplot(ax=axes[0], data=dfe, x='channel_preference', palette='Set2')
axes[0].set_title('Channel Preference Distribution')
axes[0].set_xlabel('Channel Preference')
axes[0].set_ylabel('Jumlah Pelanggan')

# Subplot 2: Campaign Performance
sns.barplot(ax=axes[1], x=campaign_cols, y=cmp_sum.values, palette='Set2')
axes[1].set_title('Campaign Performance')
axes[1].set_xlabel('Campaign')
axes[1].set_ylabel('Total Accepted')

# Layout rapih
plt.tight_layout()
plt.show()

# Step 1: Calculate total accepted campaigns per customer
dfe['total_accepted'] = dfe[['acceptedcmp1', 'acceptedcmp2', 'acceptedcmp3', 'acceptedcmp4', 'acceptedcmp5']].sum(axis=1)

# Step 2: Classify as Accepted or Not Accepted
dfe['campaign_response'] = dfe['total_accepted'].apply(lambda x: 'Accepted' if x > 0 else 'Not Accepted')

# Step 3: Count customers by channel and response
grouped = dfe.groupby(['channel_preference', 'campaign_response']).size().unstack(fill_value=0)

# Step 4: Calculate conversion rate per channel
conversion_by_channel = dfe.groupby('channel_preference')['conversion_rate'].mean()

# Step 5: Plot
fig, ax1 = plt.subplots(figsize=(12, 7))

# Colors matched to your slide design
colors = ['#aaadb3', '#c7491c']
bar_plot = grouped[['Not Accepted', 'Accepted']].plot(
    kind='bar', stacked=True, ax=ax1, color=colors
)

# Axis labels and title
ax1.set_ylabel('Number of Customers')
ax1.set_xlabel('Channel Preference')
ax1.set_title('Channel Preference: Campaign Acceptance & Conversion Rate', fontsize=14, fontweight='bold')
ax1.tick_params(axis='x', rotation=0)
ax1.legend(title='Campaign Response', loc='upper left')
ax1.grid(False)

# Add bar labels (number of customers)
for container in bar_plot.containers:
    bar_plot.bar_label(container, label_type='center', fontsize=12, color='white', weight='bold')

# Line chart for conversion rate
ax2 = ax1.twinx()
ax2.plot(conversion_by_channel.index, conversion_by_channel.values,
         color='#ffc43d', marker='o', linewidth=2, label='Conversion Rate (%)')
ax2.set_ylabel('Conversion Rate (%)')
ax2.set_ylim(0, conversion_by_channel.max() * 1.2)
ax2.legend(loc='upper right')
ax2.grid(False)

plt.tight_layout()
plt.show()

# Step 1: Kolom campaign & hitung total accepted per channel
campaign_cols = ['acceptedcmp1', 'acceptedcmp2', 'acceptedcmp3', 'acceptedcmp4', 'acceptedcmp5']
campaign_by_channel = dfe.groupby('channel_preference')[campaign_cols].sum()

# Step 2: Plot manual barplot dengan warna dari palette custom
campaign_palette = ['#F26419', '#F6AE2D', '#2F2F2F', '#EDEDED', '#86BBD8']
fig, ax = plt.subplots(figsize=(12, 7))

# Inisialisasi posisi awal (bawah) untuk stacked
bottom_values = [0] * len(campaign_by_channel)

# Loop untuk setiap campaign (tiap layer)
for idx, col in enumerate(campaign_cols):
    bar = ax.bar(
        campaign_by_channel.index,
        campaign_by_channel[col],
        bottom=bottom_values,
        label=col,
        color=campaign_palette[idx]
    )

    # Tambah label angka di dalam batang
    for bar_rect in bar:
        height = bar_rect.get_height()
        if height > 0:
            ax.text(
                bar_rect.get_x() + bar_rect.get_width() / 2,
                bar_rect.get_y() + height / 2,
                f'{int(height)}',
                ha='center',
                va='center',
                fontsize=10,
                color='black' if campaign_palette[idx] != '#2F2F2F' else 'white',
                fontweight='bold'
            )

    # Update posisi bottom
    bottom_values = [i + j for i, j in zip(bottom_values, campaign_by_channel[col])]

# Beautify
ax.set_title('Campaign Performance per Channel', fontsize=14, fontweight='bold')
ax.set_xlabel('Channel Preference')
ax.set_ylabel('Total Accepted Campaigns')
ax.legend(title='Campaign')
plt.xticks(rotation=0)

# Hilangkan grid
ax.grid(False)

plt.tight_layout()
plt.show()

"""# **2. Data Preprocessing**"""

# Display the information about the DataFrame
print("DataFrame Information:")
dfe.info()

pd.set_option('display.max_columns', None)

# Pilih kolom-kolom bertipe objek dan simpan dalam variabel 'categoric'
categoric = dfe.select_dtypes('object')

# Pilih kolom-kolom bertipe numerik dan simpan dalam variabel 'numeric'
numeric = dfe.select_dtypes('number')

# Tentukan jumlah baris dan kolom
rows = dfe.shape[0]
cols = dfe.shape[1]

# Cetak bentuk DataFrame
print(f'Jumlah Baris: {rows}\nJumlah Kolom: {cols}')

# Cetak sampel 6 baris dari DataFrame
print('\nContoh Data:')
display(dfe.sample(6))

# Cetak ringkasan statistik data kategorikal
print('\nRingkasan Statistik Data Kategorikal:')
display(categoric.describe())

# Cetak ringkasan statistik data numerik
print('\nRingkasan Statistik Data Numerik:')
display(numeric.describe())

# Define categorical_col and numerical_col before printing
categorical_col = categoric.columns.tolist()  # Get the list of categorical columns
numerical_col = numeric.columns.tolist()    # Get the list of numerical columns

print("Categorical columns: ", categorical_col)
print("Numerical columns: ", numerical_col)

"""Drop fitur unneseccery"""

drop_columns = [
    'unnamed: 0',      #  Index otomatis dari file CSV, tidak relevan untuk analisis
    'id',              #  ID unik customer, tidak memberikan insight perilaku pelanggan
    'year_birth',      #  Sudah diubah jadi 'age', jadi redundan
    'dt_customer', # sudah dijadikan age

    #  Sudah digabung ke dalam 'total_children'
    'kidhome',
    'teenhome',

    # Kolom pembelian channel ‚Äî sudah diringkas jadi 'total_purchases':
    'numdealspurchases',
    'numwebpurchases',
    'numcatalogpurchases',
    'numstorepurchases',

    # Respon kampanye marketing ‚Äî sudah diringkas 'total_responses':
    'acceptedcmp1',
    'acceptedcmp2',
    'acceptedcmp3',
    'acceptedcmp4',
    'acceptedcmp5',
    'response',

    'z_costcontact',  #  Variabel konstan, semua nilainya sama, tidak berguna untuk clustering
    'z_revenue',       #  Sama seperti di atas, variabel konstan, tidak menambah variasi

    # sudah ada total_spent
    'total_product_spent'
]

dfe_bfcapped = dfe.copy()

# Drop kolom dan simpan ke dfe_bfcapped
dfe_bfcapped = dfe.drop(columns=drop_columns)

# Get numerical columns from the DataFrame 'df'
num_columns = dfe_bfcapped.select_dtypes(include=['number']).columns

# Now you can use 'num_columns' as intended
num_columns # numerical columns

"""## **Handling Outlier**"""

import matplotlib.pyplot as plt
import seaborn as sns
import math

def plot_outliers(df, num_cols, cols_per_row=4, row_height=4, col_width=5):
    total = len(num_cols)
    rows = math.ceil(total / cols_per_row)
    figsize = (col_width * cols_per_row, row_height * rows)

    plt.style.use('default')  # Background putih
    fig, axes = plt.subplots(rows, cols_per_row, figsize=figsize)
    axes = axes.flatten()

    for i, col in enumerate(num_cols):
        sns.boxplot(y=df[col], ax=axes[i], color='steelblue', linewidth=1)
        axes[i].set_title(f'{col}', fontsize=10)
        axes[i].set_ylabel('')
        axes[i].grid(True, linestyle='--', alpha=0.5)

    # Hapus subplot kosong
    for j in range(i + 1, len(axes)):
        fig.delaxes(axes[j])

    plt.tight_layout()
    plt.suptitle('Boxplots of Numerical Features', fontsize=14, y=1.02)
    plt.show()

# function call
plot_outliers(dfe_bfcapped, num_columns)

def outliers_info(series):
    Q1 = series.quantile(0.25)
    Q3 = series.quantile(0.75)
    IQR = Q3 - Q1
    upper_bound = Q3 + 1.5 * IQR
    lower_bound = Q1 - 1.5 * IQR

    count = ((series < lower_bound) | (series > upper_bound)).sum()
    return count, upper_bound, lower_bound

def print_outliers(df, num_cols):
    outliers_dict = {}  # store the column name and the number of outliers present

    for col in num_cols:
        count, upper, lower = outliers_info(df[col])  # gunakan variabel baru

        if count > 0:
            outliers_dict[col] = count  # simpan hanya kolom yang punya outlier

    # Sort hasilnya dari yang paling banyak outlier
    sorted_outliers = dict(sorted(outliers_dict.items(), key=lambda item: item[1], reverse=True))

    # Tampilkan
    for col, val in sorted_outliers.items():
        print(f'Total outliers in {col}: {val} ({((val/len(dfe)) * 100):.2f}%)')

    print(f'\nTotal columns with outliers: {len(sorted_outliers)} out of {len(num_cols)}')

print_outliers(dfe_bfcapped, num_columns)

def cap_outliers(dfedfe_bfcapped, num_cols):
  for col in num_cols:
    _, upper_bound, lower_bound = outliers_info(dfe_bfcapped[col])  # Ambil batas atas & bawah via IQR
    dfe_bfcapped[col] = dfe_bfcapped[col].clip(lower_bound, upper_bound)      # Potong (clip) nilai ekstrem
  return dfe_bfcapped

# function call
dfe_capped = cap_outliers(dfe_bfcapped, num_columns)

# recheck outliers
print_outliers(dfe_capped, num_columns)

dfe_capped.sample(5)

dfe_capped.describe().T

drop_columns = [

    # Kolom individual spending produk ‚Äî sudah diringkas jadi 'total_spent':
    'mntcoke',
    'mntfruits',
    'mntmeatproducts',
    'mntfishproducts',
    'mntsweetproducts',
    'mntgoldprods' ]

dfe_evaluation = dfe_bfcapped.copy()

# Drop kolom dan simpan ke dfe_bfcapped
dfe_capped = dfe_bfcapped.drop(columns=drop_columns)

dfe_capped

"""## **Feature Encoding**"""

# recheck missing values
check_nan(dfe_evaluation)

# Check categorical features in dfe_capped
categorical_cols_capped = dfe_capped.select_dtypes(include=['object', 'category']).columns.tolist()
print("Categorical columns in dfe_capped:", categorical_cols_capped)

for col in categorical_cols_capped:
    print(f"\nCategories in {col}:")
    print(dfe_capped[col].value_counts())

"""### **Label Encoding, OHE & Binary**"""

# Ordinal encoding for ordered categorical columns
ordinal_mapping = {
    'education': ['SMA', 'D3', 'S1', 'S2', 'S3'],  # Berdasarkan grafik conversion
    'age_group': ['Young Adults', 'Middled-aged Adults', 'Old Adults'],  # Young paling tinggi
    'tenure_group': ['Very Short', 'Short', 'Medium', 'Long', 'Very Long'],  # Sesuai grafik
    'income_level': ['Low Income', 'Moderate Income', 'High Income', 'Very High Income'],  # Sesuai grafik
    'recency_group': ['Recent', 'Moderate', 'Less Recent', 'Inactive']  # Sesuai grafik
}

for col, order in ordinal_mapping.items():
    dfe_capped[col] = pd.Categorical(dfe_capped[col], categories=order, ordered=True).codes

# One-hot encoding for nominal columns
dfe_encoded = pd.get_dummies(dfe_capped, columns=['marital_status', 'channel_preference'], drop_first=True)

# Binary encoding for campaign_response
dfe_encoded['campaign_response'] = dfe_encoded['campaign_response'].map({'Not Accepted': 0, 'Accepted': 1})

num_cols = dfe_encoded.select_dtypes(include=np.number).columns.tolist()

skew_type_list = []
skew_val_list = []
kurtosis_val_list = []

for column in num_cols:
    data = dfe_encoded[column].dropna(axis=0)
    mean = round(data.mean(), 3)
    median = data.median()
    mode = data.mode()[0]
    skew_val = round(skew(data, nan_policy="omit"), 3)
    kurtosis_val = round(kurtosis(data, nan_policy="omit"), 3)

    if (mean == median == mode) or (-0.2 < skew_val < 0.2):
        skew_type = "Normal Distribution (Symmetric)"
    elif mean < median < mode:
        skew_type = "Negatively Skewed"
        if skew_val <= -1:
            skew_type = "Highly Negatively Skewed"
        elif -0.5 >= skew_val > -1:
            skew_type = "Moderately Negatively Skewed"
        else:
            skew_type = "Moderately Normal Distribution (Symmetric)"
    else:
        skew_type = "Positively Skewed"
        if skew_val >= 1:
            skew_type = "Highly Positively Skewed"
        elif 0.5 <= skew_val < 1:
            skew_type = "Moderately Positively Skewed"
        else:
            skew_type = "Moderately Normal Distribution (Symmetric)"

    skew_type_list.append(skew_type)
    skew_val_list.append(skew_val)
    kurtosis_val_list.append(kurtosis_val)

dist = pd.DataFrame({
    "Column Name": num_cols,
    "Skewness": skew_val_list,
    "Kurtosis": kurtosis_val_list,
    "Type of Distribution": skew_type_list
})

dist = dist.sort_values(["Type of Distribution", "Column Name"]).reset_index(drop=True)
dist

"""## **Feature Scalling**

### **MinMax Scaller**
"""

from sklearn.preprocessing import MinMaxScaler

# Drop campaign_response karena itu target, bukan untuk clustering
features_for_clustering = dfe_encoded.drop(columns=['campaign_response'])

# Scaling
scaler = MinMaxScaler()
X_scaled = scaler.fit_transform(features_for_clustering)

# (Optional) Simpan ke DataFrame lagi
X_scaled_df = pd.DataFrame(X_scaled, columns=features_for_clustering.columns)
X_scaled_df.sample(5)

# recheck missing values
check_nan(X_scaled_df)

"""#### **Feature Selection RFM + Loyalty or Use All conversion Rate analysis ?**

**RFM + Loyalty**

Recency	R (Recency)	Asli dan numerik, lebih presisi dibanding RecencyGroup.

TotalPurchases	F (Frequency)	Mewakili seberapa sering pelanggan bertransaksi.

TotalSpending	M (Monetary)	Total nilai uang yang dibelanjakan oleh pelanggan.

ConversionRate	Loyalty	Indikator seberapa sering pelanggan merespons campaign.

NumWebVisitsMonth	Loyalty	Frekuensi interaksi dengan kanal digital (loyalty proxy).

TenureDays	Loyalty duration	Semakin lama pelanggan bertahan, semakin loyal kemungkinan besar.
"""

# 1. Salin dataframe utama
df_rfm = X_scaled_df.copy()

# 2. Ambil hanya kolom-kolom untuk RFM + Loyalty Clustering
df_rfm = df_rfm[[
    'recency',
    'total_purchases',
    'total_spent',
    'conversion_rate',
    'numwebvisitsmonth',
    'tenure_days'
]]

df_rfm

# recheck missing values
check_nan(df_rfm)

"""# **3.Modelling**

### **PCA use RFM + Loyalty**
"""

# Fit PCA
pca = PCA()
pca.fit(df_rfm)

# Explained Variance Ratio
explained_var = pca.explained_variance_ratio_
cumulative_var = explained_var.cumsum()

# Visualisasi cumulative variance
plt.figure(figsize=(8, 5))
plt.plot(range(1, len(cumulative_var) + 1), cumulative_var, marker='o')
plt.axhline(y=0.85, color='r', linestyle='--', label='85% Variance Threshold')
plt.title('Cumulative Explained Variance by PCA Components')
plt.xlabel('Number of Components')
plt.ylabel('Cumulative Explained Variance')
plt.grid(True)
plt.legend()

# PCA dengan 2 komponen
pca_2_rfm = PCA(n_components=2)
X_pca_2_rfm = pca_2_rfm.fit_transform(df_rfm)
pca_columns_2_rfm = [f'PC{i+1}' for i in range(2)]
X_pca_df_2_rfm = pd.DataFrame(X_pca_2_rfm, columns=pca_columns_2_rfm)

# PCA dengan 3 komponen
pca_3_rfm = PCA(n_components=3)
X_pca_3_rfm = pca_3_rfm.fit_transform(df_rfm)
pca_columns_3_rfm = [f'PC{i+1}' for i in range(3)]
X_pca_df_3_rfm = pd.DataFrame(X_pca_3_rfm, columns=pca_columns_3_rfm)

# Contoh tampilkan masing-masing 3 sampel
print("PCA - 2 Components:")
print(X_pca_df_2_rfm.sample(3))
print("\nPCA - 3 Components:")
print(X_pca_df_3_rfm.sample(3))

# Dictionary untuk menyimpan hasil inertia dan silhouette
inertia_scores = {}
silhouette_scores = {}

# Daftar jumlah komponen PCA yang mau kita hitung (khusus RFM + Loyalty)
pca_sets = {
    2: X_pca_df_2_rfm,
    3: X_pca_df_3_rfm
}

# Iterasi untuk masing-masing jumlah komponen PCA
for n_comp, X_pca in pca_sets.items():
    inertia = []
    silhouette = []

    for k in range(2, 10):
        kmeans = KMeans(n_clusters=k, random_state=12, n_init=10)
        kmeans.fit(X_pca)
        inertia.append(kmeans.inertia_)
        silhouette.append(silhouette_score(X_pca, kmeans.labels_))

    inertia_scores[n_comp] = inertia
    silhouette_scores[n_comp] = silhouette

# Unpack ke variabel untuk visualisasi nanti
inertia_2 = inertia_scores[2]
silhouette_2 = silhouette_scores[2]

inertia_3 = inertia_scores[3]
silhouette_3 = silhouette_scores[3]

sns.set(style="whitegrid", palette="muted", font_scale=1.1)

# Setup subplot 1x2 karena hanya pakai PCA 2 dan 3 komponen
fig, axs = plt.subplots(1, 2, figsize=(18, 6))
fig.suptitle('Elbow & Silhouette Score Comparison (PCA 2 & 3 Komponen)', fontsize=18, fontweight='bold')
fig.patch.set_facecolor("#F8F8F8")

# Fungsi bantu plot kombinasi inertia & silhouette
def plot_metric(ax, inertia, silhouette, title):
    ax.plot(range(2, 10), inertia, marker='o', linestyle='-', color='#1f77b4')
    ax.set_xlabel('Jumlah Cluster (k)', fontsize=12)
    ax.set_ylabel('Inertia', fontsize=12, color='#1f77b4')
    ax.tick_params(axis='y', labelcolor='#1f77b4')

    ax2 = ax.twinx()
    ax2.plot(range(2, 10), silhouette, marker='s', linestyle='--', color='#d62728')
    ax2.set_ylabel('Silhouette Score', fontsize=12, color='#d62728')
    ax2.tick_params(axis='y', labelcolor='#d62728')

    ax.set_title(title, fontsize=14)

# Plot untuk PCA 2 dan 3 komponen
plot_metric(axs[0], inertia_2, silhouette_2, 'PCA - 2 Komponen')
plot_metric(axs[1], inertia_3, silhouette_3, 'PCA - 3 Komponen')

# Tata letak
plt.tight_layout(rect=[0, 0.03, 1, 0.95])
plt.show()

fig, ax = plt.subplots(2, 2, figsize=(15, 8))
fig.set_facecolor("#F5F5F5")  # Warna latar belakang yang bersih dan lembut

# Loop jumlah cluster dari 2 sampai 5
for k in range(2, 6):
    # Inisialisasi KMeans
    kmeans = KMeans(n_clusters=k, random_state=12, n_init=10)

    # Tentukan posisi subplot
    row, col = divmod(k-2, 2)

    # Buat visualisasi Silhouette
    visualizer = SilhouetteVisualizer(kmeans, colors='yellowbrick', ax=ax[row][col])
    visualizer.fit(X_pca_df_2_rfm)  # Gunakan data hasil PCA 2 komponen dari df_rfm

    # Tambahkan judul dan label sumbu
    ax[row][col].set_title(f'Silhouette Plot (k = {k}) - PCA 2 RFM', fontsize=13, fontweight='bold')
    ax[row][col].set_xlabel('Koefisien Silhouette', fontsize=11)
    ax[row][col].set_ylabel('Label Klaster', fontsize=11)
    ax[row][col].grid(True, linestyle='--', alpha=0.5)

# Rapikan layout antar plot
plt.tight_layout()
plt.show()

# Inisialisasi dan fit model
kmeans_pca2_rfm = KMeans(n_clusters=4, random_state=42, n_init=10)
kmeans_pca2_rfm.fit(X_pca_df_2_rfm)

# Tambahkan hasil klaster ke data
X_pca_df_2_rfm['Cluster'] = kmeans_pca2_rfm.labels_

# Create a new figure with a specified size and background color
plt.figure(figsize=(12, 8), facecolor='#E8E8E8')

# Warna palette custom
palt = ['#25A9D9', '#00D19B', '#D1106F', '#D16F11']

# Plot scatter hasil klasterisasi
sns.scatterplot(x='PC1', y='PC2', hue='Cluster', data=X_pca_df_2_rfm, palette=palt)

# Ambil koordinat pusat klaster dari model KMeans
centroids = kmeans_pca2_rfm.cluster_centers_

# Plot pusat klaster sebagai tanda 'x' hitam
plt.scatter(centroids[:, 0], centroids[:, 1], c='black', s=200, alpha=0.8, marker='x')

# Set judul dan label
plt.title('K-Means Clustering (PCA 2 Komponen - RFM)', fontsize=18, fontweight='bold', y=1.03)
plt.xlabel('PCA 1', fontsize=12)
plt.ylabel('PCA 2', fontsize=12)
plt.grid(False)
plt.show()

"""### **PCA no use feature RFM**"""

from sklearn.decomposition import PCA
import matplotlib.pyplot as plt

pca = PCA()
pca.fit(X_scaled)

# Explained Variance Ratio
explained_var = pca.explained_variance_ratio_
cumulative_var = explained_var.cumsum()

# Visualisasi dengan style & palette custom
plt.figure(figsize=(8, 5))
plt.plot(range(1, len(cumulative_var) + 1), cumulative_var,
         marker='o', linestyle='-', color='#2c3e50', label='Cumulative Variance')

# Garis threshold 85%
plt.axhline(y=0.85, color='#e74c3c', linestyle='--', label='85% Variance Threshold')

# Styling
plt.title('Cumulative Explained Variance by PCA Components', fontsize=14, fontweight='bold')
plt.xlabel('Number of Components', fontsize=12)
plt.ylabel('Cumulative Explained Variance', fontsize=12)
plt.xticks(fontsize=10)
plt.yticks(fontsize=10)
plt.grid(False)  # Remove grid
plt.legend(frameon=False)
plt.tight_layout()
plt.show()

"""Kita ingin mengambil jumlah komponen PCA yang mampu menjelaskan >85% variansi data.

Dari grafik, terlihat bahwa komponen ke-8 merupakan titik di mana cumulative explained variance baru saja melewati 85% (threshold yang ditandai dengan garis merah putus-putus).

Setelah komponen ke-8, penambahan komponen berikutnya tidak memberikan peningkatan signifikan (diminishing returns), sehingga tidak efisien secara model.

Maka, komponen 1‚Äì8 sudah optimal untuk digunakan, karena mampu menangkap informasi utama tanpa terlalu banyak kehilangan insight penting dari data asli.
"""

from sklearn.decomposition import PCA
import pandas as pd

# PCA dengan 2 komponen
pca_2 = PCA(n_components=2)
X_pca_2 = pca_2.fit_transform(X_scaled)
pca_columns_2 = [f'PC{i+1}' for i in range(2)]
X_pca_df_2 = pd.DataFrame(X_pca_2, columns=pca_columns_2)

# PCA dengan 3 komponen
pca_3 = PCA(n_components=3)
X_pca_3 = pca_3.fit_transform(X_scaled)
pca_columns_3 = [f'PC{i+1}' for i in range(3)]
X_pca_df_3 = pd.DataFrame(X_pca_3, columns=pca_columns_3)

# PCA dengan 4 komponen
pca_4 = PCA(n_components=4)
X_pca_4 = pca_4.fit_transform(X_scaled)
pca_columns_4 = [f'PC{i+1}' for i in range(4)]
X_pca_df_4 = pd.DataFrame(X_pca_4, columns=pca_columns_4)

# PCA dengan 8 komponen
pca_8 = PCA(n_components=8)
X_pca_8 = pca_8.fit_transform(X_scaled)
pca_columns_8 = [f'PC{i+1}' for i in range(8)]
X_pca_df_8 = pd.DataFrame(X_pca_8, columns=pca_columns_8)

# Contoh tampilkan masing-masing 3 sampel
print("PCA - 2 Components:")
print(X_pca_df_2.sample(3))
print("\nPCA - 3 Components:")
print(X_pca_df_3.sample(3))
print("PCA - 4 Components:")
print(X_pca_df_4.sample(3))
print("\nPCA - 8 Components:")
print(X_pca_df_8.sample(3))

from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score

# Dictionary untuk menyimpan hasil inertia dan silhouette
inertia_scores = {}
silhouette_scores = {}

# Daftar jumlah komponen PCA yang mau kita hitung
pca_sets = {
    2: X_pca_df_2,
    3: X_pca_df_3,
    4: X_pca_df_4,
    8: X_pca_df_8
}

# Iterasi untuk masing-masing jumlah komponen PCA
for n_comp, X_pca in pca_sets.items():
    inertia = []
    silhouette = []

    for k in range(2, 10):
        kmeans = KMeans(n_clusters=k, random_state=12, n_init=10)
        kmeans.fit(X_pca)
        inertia.append(kmeans.inertia_)
        silhouette.append(silhouette_score(X_pca, kmeans.labels_))

    inertia_scores[n_comp] = inertia
    silhouette_scores[n_comp] = silhouette

# Unpack ke variabel agar sesuai dengan visualisasi sebelumnya
inertia_2 = inertia_scores[2]
silhouette_2 = silhouette_scores[2]

inertia_3 = inertia_scores[3]
silhouette_3 = silhouette_scores[3]

inertia_4 = inertia_scores[4]
silhouette_4 = silhouette_scores[4]

inertia_8 = inertia_scores[8]
silhouette_8 = silhouette_scores[8]

"""### **Elbow & Silhouette**"""

# Custom color palette matching slide style
sns.set(style="white", font_scale=1.1)  # "white" to remove grid background

# Setup subplot 2x2
fig, axs = plt.subplots(2, 2, figsize=(18, 12))
fig.suptitle('Elbow & Silhouette Score Comparison (PCA with 2, 3, 4, 8 Components)',
             fontsize=18, fontweight='bold')
fig.patch.set_facecolor("#F8F8F8")

# Custom colors
inertia_color = "#2c3e50"     # Dark blue/gray
silhouette_color = "#e74c3c"  # Soft red

# Helper function to plot combined inertia & silhouette
def plot_metric(ax, inertia, silhouette, title):
    ax.plot(range(2, 10), inertia, marker='o', linestyle='-', color=inertia_color)
    ax.set_xlabel('Number of Clusters (k)', fontsize=12)
    ax.set_ylabel('Inertia', fontsize=12, color=inertia_color)
    ax.tick_params(axis='y', labelcolor=inertia_color)
    ax.grid(False)  # remove grid from left axis

    ax2 = ax.twinx()
    ax2.plot(range(2, 10), silhouette, marker='s', linestyle='--', color=silhouette_color)
    ax2.set_ylabel('Silhouette Score', fontsize=12, color=silhouette_color)
    ax2.tick_params(axis='y', labelcolor=silhouette_color)
    ax2.grid(False)  # remove grid from right axis

    ax.set_title(title, fontsize=14)

# Plot each combination
plot_metric(axs[0, 0], inertia_2, silhouette_2, 'PCA - 2 Components')
plot_metric(axs[0, 1], inertia_3, silhouette_3, 'PCA - 3 Components')
plot_metric(axs[1, 0], inertia_4, silhouette_4, 'PCA - 4 Components')
plot_metric(axs[1, 1], inertia_8, silhouette_8, 'PCA - 8 Components')

# Layout adjustment
plt.tight_layout(rect=[0, 0.03, 1, 0.95])
plt.show()

"""Inertia: Semakin kecil, semakin baik (mengindikasikan cluster yang lebih kompak).

Silhouette Score: Semakin mendekati 1, semakin baik (mengukur pemisahan antar cluster).

Cari keseimbangan antara keduanya dan perhatikan ‚Äúelbow‚Äù serta puncak silhouette.

‚úÖ PCA dengan 3 Komponen:

Silhouette Score tertinggi muncul pada k = 6 dan k = 5, dengan nilai ~0.48‚Äì0.49 (tertinggi dibanding lainnya).

Inertia turun signifikan dan cukup stabil setelah k = 5‚Äì6.

‚Üí Ini jadi kandidat terbaik.

‚ùå PCA dengan 2 Komponen:

Meskipun inertia cukup rendah, silhouette score stagnan setelah k = 3 dan malah menurun.

Tidak ada peningkatan signifikan setelah k = 4.

‚ùå PCA dengan 4 Komponen:

Inertia menurun stabil, tapi silhouette score lebih rendah (~0.31‚Äì0.37).

Tidak ada puncak tajam, lebih datar dan kurang terpisah.

‚ùå PCA dengan 8 Komponen:

Inertia memang lebih tinggi karena dimensi lebih kompleks.

Tapi silhouette score paling rendah (sekitar 0.19‚Äì0.22), artinya pemisahan antar cluster buruk.

**Pemilihan PCA 3**

Memberikan kombinasi terbaik antara inertia yang masuk akal dan silhouette score tertinggi (~0.49).

Cluster terlihat paling optimal untuk dilanjutkan ke tahap modeling dan interpretasi persona.
"""

from yellowbrick.cluster import SilhouetteVisualizer

# Buat subplot 2x2
fig, ax = plt.subplots(2, 2, figsize=(15, 8))
fig.set_facecolor("#F5F5F5")  # Warna latar belakang yang bersih dan lembut

# Loop jumlah cluster dari 2 sampai 5
for k in range(2, 6):
    # Inisialisasi KMeans
    kmeans = KMeans(n_clusters=k, random_state=12, n_init=10)

    # Tentukan posisi subplot
    row, col = divmod(k-2, 2)

    # Buat visualisasi Silhouette
    visualizer = SilhouetteVisualizer(kmeans, colors='yellowbrick', ax=ax[row][col])
    visualizer.fit(X_pca_df_2)  # Gunakan data hasil PCA 3 komponen

    # Tambahkan judul dan label sumbu
    ax[row][col].set_title(f'Silhouette Plot (k = {k})', fontsize=13, fontweight='bold')
    ax[row][col].set_xlabel('Koefisien Silhouette', fontsize=11)
    ax[row][col].set_ylabel('Label Klaster', fontsize=11)
    ax[row][col].grid(True, linestyle='--', alpha=0.5)

# Rapikan layout antar plot
plt.tight_layout()
plt.show()

from sklearn.metrics import davies_bouldin_score, calinski_harabasz_score
from sklearn.cluster import KMeans

# Ambil data PCA 2 komponen
X_pca = pca_sets[2]

# Fit KMeans dengan 4 klaster
kmeans = KMeans(n_clusters=4, random_state=42)
cluster_labels = kmeans.fit_predict(X_pca)

# Hitung Davies-Bouldin Index
dbi_score = davies_bouldin_score(X_pca, cluster_labels)

# Hitung Calinski-Harabasz Score
ch_score = calinski_harabasz_score(X_pca, cluster_labels)

print(f"Davies-Bouldin Index: {dbi_score:.3f}")
print(f"Calinski-Harabasz Score: {ch_score:.3f}")

pca_sets = {
    2: X_pca_df_2,
    3: X_pca_df_3,
    4: X_pca_df_4,
    8: X_pca_df_8
}

# Prepare list to store results
results = []

# Loop through each PCA set and number of clusters
for n_components, X_pca in pca_sets.items():
    for n_clusters in range(2, 10):  # Cluster count from 2 to 9
        kmeans = KMeans(n_clusters=n_clusters, random_state=42)
        labels = kmeans.fit_predict(X_pca)
        db_index = davies_bouldin_score(X_pca, labels)
        ch_score = calinski_harabasz_score(X_pca, labels)
        results.append({
            'PCA Components': n_components,
            'Clusters': n_clusters,
            'Davies-Bouldin Index': db_index,
            'Calinski-Harabasz Score': ch_score
        })

# Convert results to DataFrame
results_df = pd.DataFrame(results)
results_df.sort_values(by=['PCA Components', 'Clusters'], inplace=True)
results_df.reset_index(drop=True, inplace=True)
results_df

# Filter data untuk PCA=2 dan Clusters=3 sampai 6
filtered_df = results_df[(results_df["PCA Components"] == 2) & (results_df["Clusters"].between(3, 6))]

# Set index dan pivot untuk heatmap
heatmap_data = filtered_df.pivot(index="Clusters", columns="PCA Components", values="Davies-Bouldin Index")

# Buat heatmap
plt.figure(figsize=(6, 4))
sns.heatmap(heatmap_data, annot=True, fmt=".3f", cmap="YlGnBu", cbar_kws={'label': 'Davies-Bouldin Index'})
plt.title("Davies-Bouldin Index - PCA 2 Components")
plt.xlabel("PCA Components")
plt.ylabel("Number of Clusters")
plt.tight_layout()
plt.show()

# Filter data for PCA = 2 and cluster numbers from 3 to 6
filtered_df = results_df[(results_df["PCA Components"] == 2) & (results_df["Clusters"].between(3, 6))]

# Set clean style and consistent font scale
sns.set(style="white", font_scale=1.1)
plt.figure(figsize=(10, 6))
plt.title("Clustering Evaluation - PCA with 2 Components", fontsize=16, fontweight='bold')

dbi_color = "#2c3e50"
ch_score_color = "#e74c3c"

# Left y-axis: Davies-Bouldin Index
ax1 = plt.gca()
sns.lineplot(
    data=filtered_df,
    x="Clusters",
    y="Davies-Bouldin Index",
    marker="o",
    color=dbi_color,
    linewidth=2,
    ax=ax1
)
ax1.set_ylabel("Davies-Bouldin Index", color=dbi_color)
ax1.tick_params(axis='y', labelcolor=dbi_color)

# Right y-axis: Calinski-Harabasz Score
ax2 = ax1.twinx()
sns.lineplot(
    data=filtered_df,
    x="Clusters",
    y="Calinski-Harabasz Score",
    marker="o",
    color=ch_score_color,
    linewidth=2,
    ax=ax2
)
ax2.set_ylabel("Calinski-Harabasz Score", color=ch_score_color)
ax2.tick_params(axis='y', labelcolor=ch_score_color)

# X-axis label and clean layout
ax1.set_xlabel("Number of Clusters", fontsize=12)
ax1.grid(False)
ax2.grid(False)

# Manual legend with matching colors
dbi_line = plt.Line2D([], [], color=dbi_color, marker="o", label="Davies-Bouldin Index")
ch_line = plt.Line2D([], [], color=ch_score_color, marker="o", label="Calinski-Harabasz Score")
ax1.legend(handles=[dbi_line, ch_line], loc="upper left", frameon=False)

plt.tight_layout()
plt.show()

"""#### **Why PCA 2 + k=4 adalah kombinasi terbaik?**

Berdasarkan visualisasi dan metrik silhouette, kombinasi PCA 2 dengan k = 4 memberikan segmentasi pelanggan yang paling optimal. Pendekatan ini menyeimbangkan kualitas clustering, kemudahan interpretasi, dan potensi dampak bisnis, sehingga cocok digunakan dalam strategi marketing berbasis personality.
"""

# Set jumlah cluster optimal ke 4
k_optimal = 4

# Inisialisasi objek KMeans dengan jumlah cluster optimal
kmeans = KMeans(n_clusters=k_optimal, random_state=120, n_init='auto')

# Fit model KMeans ke data hasil PCA (2 komponen)
kmeans.fit(X_pca_df_2)

# Tambahkan label klaster ke dataframe PCA
X_pca_df_2['Cluster'] = kmeans.labels_

# Tampilkan dataframe hasil klastering
X_pca_df_2

"""## **K-Means Clustering**"""

from sklearn.cluster import KMeans

# Inisialisasi dan fit model
kmeans_pca2 = KMeans(n_clusters=4, random_state=42, n_init=10)
kmeans_pca2.fit(X_pca_df_2)

# Tambahkan hasil klaster ke data
X_pca_df_2['Cluster'] = kmeans_pca2.labels_

# Create a new figure with a specified size and background color
plt.figure(figsize=(12,8), facecolor='#E8E8E8')

# Create a scatter plot of the first principal component ('PC1') against the second principal component ('PC2')
# The points are colored according to their cluster label
palt = ['#25A9D9', '#00D19B', '#D1106F', '#D16F11']
sns.scatterplot(x='PC1', y='PC2', hue='Cluster', data=X_pca_df_2, palette=palt)

# Get the coordinates of the cluster centers from the KMeans model
centroids = kmeans.cluster_centers_
# Plot the cluster centers as black 'x' markers
plt.scatter(centroids[:, 0], centroids[:, 1], c='black', s=200, alpha=0.8, marker='x')

# Set the title for the plot
plt.title('K-Means Clustering', fontsize=18, fontweight='bold', y=1.03)
# Set the label for the x-axis
plt.xlabel('PCA 1', fontsize=12)
# Set the label for the y-axis
plt.ylabel('PCA 2', fontsize=12)
# Remove the grid from the plot
plt.grid(False)
# Display the plot
plt.show()

"""# **4.Customer Personality Analysis for Marketing Retargeting**

**Hasil Akhir Menggunakan semua Feature yang sudah dipilih bukan berdasarkan RFM + loyalty saja**
"""

# Reset index agar bisa digabung
X_pca_df_2 = X_pca_df_2.reset_index(drop=True)

# Gabungkan cluster label ke data asli yang sudah diencoding
dfe_clustered = pd.concat([dfe_evaluation, X_pca_df_2['Cluster']], axis=1)

# Tampilkan beberapa baris hasil akhir
dfe_clustered.sample(35)

# Hitung statistik deskriptif tiap cluster
cluster_summary = dfe_clustered.groupby('Cluster').agg({
    'income': 'mean',
    'total_spent': 'mean',
    'total_purchases': 'mean',
    'conversion_rate': 'mean',
    'recency': 'mean',
    'numwebvisitsmonth': 'mean',
    'age': 'mean'
}).round(2)

cluster_summary

# Buat distribusi kategorikal seperti channel preference, income level, dsb.
categorical_cols = ['channel_preference', 'income_level', 'age_group', 'recency_group']
for col in categorical_cols:
    print(f"\nDistribusi {col} per Cluster:\n")
    display(pd.crosstab(dfe_clustered['Cluster'], dfe_clustered[col], normalize='index') * 100)

"""
## **Customer Persona for Cluster**
### **Cluster 0**

Income: Rendah-menengah

Spending: Paling rendah

Purchases: Paling sedikit

Channel: 99% Store

Usia: Middle-aged ke atas

Engagement Web: Rendah ‚û°Ô∏è Persona: The Conservative Buyer

Karakter: Belanja hemat, loyal ke toko fisik, pengeluaran kecil, tidak aktif secara digital.

### **Cluster 1**

Income: Sangat tinggi (75% Very High)

Spending: Paling tinggi

Conversion Rate: Tertinggi (0.18)

Channel: Store dan sedikit Catalog

Usia: Tua dan matang ‚û°Ô∏è Persona: The Steady Spender

Karakter: Mapan, pengeluaran tinggi, belanja rutin, stabil, lebih suka toko fisik.

### **Cluster 2**
Income: Rendah-menengah

Spending: Menengah

Web Use: 97% Web channel!

Purchases: Banyak juga ‚û°Ô∏è Persona: The Discount Hunter

Karakter: Aktif online, peka promo, income terbatas tapi rajin belanja, channel digital.

### **Cluster 3**

Income: Tinggi

Spending: Kedua tertinggi

Web Use: 80% Web

Age: Paling tua ‚û°Ô∏è Persona: The Trend Explorer

Karakter: Aktif online, tech-savvy meskipun lebih tua, belanja banyak dan income tinggi."""

# Mapping persona secara objektif berdasarkan insight statistik & distribusi
persona_mapping = {
    0: "The Conservative Buyer",
    1: "The Steady Spender",
    2: "The Discount Hunter",
    3: "The Trend Explorer"
}
df_clusterfinal = dfe_clustered.copy()

# Tambahkan kolom Persona ke dataset
df_clusterfinal['Persona'] = df_clusterfinal['Cluster'].map(persona_mapping)

# Tampilkan beberapa baris hasil akhir
df_clusterfinal.sample(30)

import plotly.express as px
df_pca_plot = X_pca_df_2.copy()

persona_mapping = {
    0: '0: The Conservative Buyer',
    1: '1: The Steady Spender',
    2: '2: The Discount Hunter',
    3: '3: The Trend Explorer'
}
df_pca_plot['Persona'] = df_pca_plot['Cluster'].map(persona_mapping)

# Tambah kolom hover data
df_pca_plot['income'] = df_clusterfinal['income']
df_pca_plot['age_group'] = df_clusterfinal['age_group']
df_pca_plot['channel_preference'] = df_clusterfinal['channel_preference']

fig = px.scatter(
    df_pca_plot,
    x='PC1', y='PC2',
    color='Persona',
    symbol='Persona',
    color_discrete_map={
        '0: The Conservative Buyer': '#25A9D9',
        '1: The Steady Spender': '#00D19B',
        '2: The Discount Hunter': '#D1106F',
        '3: The Trend Explorer': '#D16F11'
    },
    symbol_map={
        'The Trend Explorer': 'circle',
        'The Discount Hunter': 'diamond',
        'The Conservative Buyer': 'square',
        'The Steady Spender': 'x'
    },
    hover_data=['income', 'age_group', 'channel_preference']
)

# Tambahkan garis sumbu X dan Y
fig.add_shape(type="line", x0=0, y0=df_pca_plot['PC2'].min(), x1=0, y1=df_pca_plot['PC2'].max(),
              line=dict(color="gray", dash="dash"))

fig.add_shape(type="line", x0=df_pca_plot['PC1'].min(), y0=0, x1=df_pca_plot['PC1'].max(), y1=0,
              line=dict(color="gray", dash="dash"))

# Update layout
fig.update_layout(
    title="<b>Customer Segmentation via PCA Projection</b>",
    title_font=dict(size=22, family="Arial Black"),
    legend_title="Customer Persona",
    template='plotly_white',
    width=1000,
    height=600
)

fig.show()

"""{
    0: "The Conservative Buyer",
    1: "The Steady Spender",
    2: "The Discount Hunter",
    3: "The Trend Explorer"
}

## **Persona by Age Group**
"""

# Gunakan palet warna sesuai slide
custom_palette = ['#F26419', '#F6AE2D', '#2F2F2F', '#EDEDED', '#86BBD8', '#33658A']

plt.figure(figsize=(10, 6))
ax = sns.countplot(
    data=df_clusterfinal,
    x='Persona',
    hue='age_group',
    palette=custom_palette,
    order=[
        'The Conservative Buyer',
        'The Steady Spender',
        'The Discount Hunter',
        'The Trend Explorer'
    ]
)

# Tambahkan label pada setiap bar
for container in ax.containers:
    ax.bar_label(container, fmt='%d', label_type='edge', padding=3)

sns.despine()
plt.title('Age Group by Customer Persona', fontsize=14, fontweight='bold')
plt.xlabel('Persona', fontsize=12)
plt.ylabel('Count', fontsize=12)
plt.xticks(rotation=10)
plt.grid(False)
plt.legend(title='Age Group')
plt.tight_layout()
plt.show()

"""## **Average Income by Customer Persona**"""

# Palet warna sesuai slide
custom_palette = ['#F26419', '#F6AE2D', '#2F2F2F', '#EDEDED', '#86BBD8', '#33658A']

def format_million(value):
    return f'{value/1e6:.1f}M'

plt.figure(figsize=(10, 6))
ax = sns.barplot(
    data=df_clusterfinal,
    x='Persona',
    y='income',
    estimator='mean',
    palette=custom_palette,
    order=[
        'The Conservative Buyer',
        'The Steady Spender',
        'The Discount Hunter',
        'The Trend Explorer'
    ]
)

# Tambahkan label dalam format singkat
for container in ax.containers:
    labels = [format_million(bar.get_height()) for bar in container]
    ax.bar_label(container, labels=labels, label_type='edge', padding=3)

# Format y-axis ke dalam jutaan (M)
ax.yaxis.set_major_formatter(ticker.FuncFormatter(lambda x, _: f'{x/1e6:.1f}M'))

sns.despine()
plt.title('Average Income by Customer Persona', fontsize=14, fontweight='bold')
plt.xlabel('Persona', fontsize=12)
plt.ylabel('Average Income (Million)', fontsize=12)
plt.xticks(rotation=10)
plt.grid(False)
plt.tight_layout()
plt.show()

"""## **Average Total Spending by Persona**"""

import matplotlib.ticker as ticker

custom_palette = ['#F26419', '#F6AE2D', '#2F2F2F', '#EDEDED', '#86BBD8', '#33658A']

plt.figure(figsize=(10, 6))
ax = sns.barplot(
    data=df_clusterfinal,
    x='Persona',
    y='total_spent',
    estimator='mean',
    palette=custom_palette,
    order=[
        'The Conservative Buyer',
        'The Steady Spender',
        'The Discount Hunter',
        'The Trend Explorer'
    ]
)

sns.despine()
plt.title('Average Total Spending by Persona', fontsize=14, fontweight='bold')
plt.xlabel('Persona', fontsize=12)
plt.ylabel('Average Total Spending', fontsize=12)
plt.xticks(rotation=10)

# Format y-axis menjadi jutaan (M)
ax.yaxis.set_major_formatter(ticker.FuncFormatter(lambda x, _: f'{x/1e6:.1f}M'))

# Tambahkan label nilai di atas batang
for p in ax.patches:
    height = p.get_height()
    ax.annotate(f'{height/1e6:.1f}M',
                (p.get_x() + p.get_width() / 2, height + 0.005 * height),
                ha='center', va='bottom',
                fontsize=10, color='black', fontweight='bold')

plt.grid(False)
plt.tight_layout()
plt.show()

"""## **Channel Preference by Persona**"""

# Palet warna sesuai slide
custom_palette = ['#F26419', '#F6AE2D', '#2F2F2F', '#EDEDED', '#86BBD8', '#33658A']

plt.figure(figsize=(10, 6))
ax = sns.countplot(
    data=df_clusterfinal,
    x='Persona',
    hue='channel_preference',
    palette=custom_palette,
    order=[
        'The Conservative Buyer',
        'The Steady Spender',
        'The Discount Hunter',
        'The Trend Explorer'
    ]
)

sns.despine()
plt.title('Channel Preference by Persona', fontsize=14, fontweight='bold')
plt.xlabel('Persona', fontsize=12)
plt.ylabel('Count', fontsize=12)
plt.xticks(rotation=10)
plt.grid(False)
plt.legend(title='Channel')

# Tambahkan label di atas setiap bar
for container in ax.containers:
    ax.bar_label(container, fmt='%d', label_type='edge', fontsize=9, padding=2)

plt.tight_layout()
plt.show()

"""## **Average Conversion Rate by Persona**"""

# Palet warna sesuai slide
custom_palette = ['#F26419', '#F6AE2D', '#2F2F2F', '#EDEDED', '#86BBD8', '#33658A']

plt.figure(figsize=(10, 6))
ax = sns.barplot(
    data=df_clusterfinal,
    x='Persona',
    y='conversion_rate',
    estimator='mean',
    palette=custom_palette,
    order=[
        'The Conservative Buyer',
        'The Steady Spender',
        'The Discount Hunter',
        'The Trend Explorer'
    ]
)

sns.despine()
plt.title('Average Conversion Rate by Persona', fontsize=14, fontweight='bold')
plt.xlabel('Persona', fontsize=12)
plt.ylabel('Conversion Rate', fontsize=12)
plt.xticks(rotation=15)
plt.grid(False)

# Tambahkan label nilai di atas bar (dalam persen)
for container in ax.containers:
    labels = [f'{bar.get_height():.2%}' for bar in container]
    ax.bar_label(container, labels=labels, label_type='edge', fontsize=9, padding=2)

plt.tight_layout()
plt.show()

"""## **Average Product Spending per Persona**"""

# Palet warna sesuai slide (panjang harus sesuai jumlah kategori produk)
custom_palette = ['#F26419', '#F6AE2D', '#2F2F2F', '#EDEDED', '#86BBD8', '#33658A']

# Kolom spending per produk
product_columns = [
    'mntcoke', 'mntfruits', 'mntmeatproducts',
    'mntfishproducts', 'mntsweetproducts', 'mntgoldprods'
]

# Hitung rata-rata pengeluaran tiap produk per persona
avg_spending = df_clusterfinal.groupby('Persona')[product_columns].mean().reset_index()

# Ubah ke format long (melted)
avg_spending_melted = avg_spending.melt(id_vars='Persona', var_name='Product Category', value_name='Average Spending')

# Urutan persona
persona_order = [
    'The Conservative Buyer',
    'The Steady Spender',
    'The Discount Hunter',
    'The Trend Explorer'
]

# Buat visualisasi
plt.figure(figsize=(12, 6))
ax = sns.barplot(
    data=avg_spending_melted,
    x='Persona',
    y='Average Spending',
    hue='Product Category',
    palette=custom_palette,
    order=persona_order
)

# Tambahkan label nilai di atas setiap bar dengan format ribuan
for container in ax.containers:
    labels = [f'{int(v/1000):,}K' if v >= 1000 else f'{int(v)}' for v in container.datavalues]
    ax.bar_label(container, labels=labels, label_type='edge', fontsize=8, padding=1)

plt.title('Average Product Spending per Persona', fontsize=14, fontweight='bold')
plt.xlabel('Persona', fontsize=12)
plt.ylabel('Average Spending', fontsize=12)
plt.xticks(rotation=7)
plt.legend(title='Product Category', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid(False)
plt.tight_layout()
plt.show()

"""# **5. Insight & Recommendation include in Report**"""

def format_rp(amount):
    """Formats a number into Indonesian Rupiah currency string."""
    return f"Rp {amount:,.0f}".replace(",", ".")

# Biaya campaign per customer (dalam Rupiah)
cost_per_customer = 30000

# --- SEBELUM MODELING ---
# Total pelanggan
total_customer = len(dfe)

# Rata-rata conversion rate dan total spending dari seluruh pelanggan (tanpa segmentasi)
overall_cr_before = dfe['conversion_rate'].mean()
overall_spending_before = dfe['total_spent'].mean()

# Total revenue dan cost sebelum dilakukan modeling
total_revenue_before = overall_cr_before * overall_spending_before * total_customer
total_cost_before = cost_per_customer * total_customer
roi_before = (total_revenue_before - total_cost_before) / total_cost_before

# --- SETELAH MODELING ---
# Hitung statistik rata-rata conversion rate, total spending, dan jumlah pelanggan per persona
persona_stats = df_clusterfinal.groupby('Persona').agg({
    'conversion_rate': 'mean',
    'total_spent': 'mean',
    'Persona': 'count'
}).rename(columns={'Persona': 'count'}).reset_index()

# Tentukan dua persona terbaik berdasarkan kombinasi conversion rate dan total spending
top_personas = persona_stats.sort_values(by=['conversion_rate', 'total_spent'], ascending=False).head(2)['Persona'].tolist()
target_df = df_clusterfinal[df_clusterfinal['Persona'].isin(top_personas)]

# Rata-rata conversion rate dari

# Biaya campaign per customer (dalam Rupiah)
cost_per_customer = 30000

# --- SEBELUM MODELING ---
# Total pelanggan
total_customer = len(dfe)

# Rata-rata conversion rate dan total spending dari seluruh pelanggan (tanpa segmentasi)
overall_cr_before = dfe['conversion_rate'].mean()
overall_spending_before = dfe['total_spent'].mean()

# Total revenue dan cost sebelum dilakukan modeling
total_revenue_before = overall_cr_before * overall_spending_before * total_customer
total_cost_before = cost_per_customer * total_customer
roi_before = (total_revenue_before - total_cost_before) / total_cost_before

# --- SETELAH MODELING ---
# Hitung statistik rata-rata conversion rate, total spending, dan jumlah pelanggan per persona
persona_stats = df_clusterfinal.groupby('Persona').agg({
    'conversion_rate': 'mean',
    'total_spent': 'mean',
    'Persona': 'count'
}).rename(columns={'Persona': 'count'}).reset_index()

# Tentukan dua persona terbaik berdasarkan kombinasi conversion rate dan total spending
top_personas = persona_stats.sort_values(by=['conversion_rate', 'total_spent'], ascending=False).head(2)['Persona'].tolist()
target_df = df_clusterfinal[df_clusterfinal['Persona'].isin(top_personas)]

# Rata-rata conversion rate dari pelanggan yang ditarget
overall_cr_after = target_df['conversion_rate'].mean()
overall_spending_after = target_df['total_spent'].mean()

# Total revenue dan cost setelah dilakukan segmentasi dan targeting
total_revenue_after = (target_df['conversion_rate'] * target_df['total_spent']).sum()
total_cost_after = cost_per_customer * len(target_df)
roi_after = (total_revenue_after - total_cost_after) / total_cost_after

# Perubahan dan peningkatan conversion rate
cr_improvement = overall_cr_after - overall_cr_before
cr_improvement_pct = (cr_improvement / overall_cr_before) * 100

# Cetak hasil dalam format seperti business report
print("=== Business Impact Summary ===\n")
print(f"Total Customers (Before): {total_customer:,}")
print(f"üîµ Average Conversion Rate (Before Targeting): {overall_cr_before:.4f}")
print(f"Total Revenue (Before): Rp {total_revenue_before:,.0f}")
print(f"Total Cost (Before): Rp {total_cost_before:,.0f}")
print(f"ROI (Before): {roi_before:.2f}")

print(f"\nTargeted Customers (After): {len(target_df):,}")
print(f"üü¢ Average Conversion Rate (After Targeting): {overall_cr_after:.4f}")
print(f"Targeted Personas: {', '.join(top_personas)}")
print(f"Total Revenue (After): Rp {total_revenue_after:,.0f}")
print(f"Total Cost (After): Rp {total_cost_after:,.0f}")
print(f"ROI (After): {roi_after:.2f}")

print("\n=== Business Impact ===\n")
print(f"üìà Improvement Average Conversion Rate: {cr_improvement:.4f} ({cr_improvement_pct:.2f}%)")
print(f"üîº Revenue Increase: {format_rp(revenue_gain)} ({(revenue_gain / total_revenue_before) * 100:.2f}%)")
print(f"üí° ROI Improvement: {roi_gain:.2f}x")
print(f"üí∞ Cost Saving: {format_rp(cost_saving)} ({(cost_saving / total_cost_before) * 100:.2f}%)")

def format_rp(amount):
    """Formats a number into Indonesian Rupiah currency string."""
    return f"Rp {amount:,.0f}".replace(",", ".")

# Biaya campaign per customer (dalam Rupiah)
cost_per_customer = 30000

# --- SEBELUM MODELING ---
# Total pelanggan
total_customer = len(dfe)

# Rata-rata conversion rate dan total spending dari seluruh pelanggan (tanpa segmentasi)
overall_cr_before = dfe['conversion_rate'].mean()
overall_spending_before = dfe['total_spent'].mean()

# Total revenue dan cost sebelum dilakukan modeling
total_revenue_before = overall_cr_before * overall_spending_before * total_customer
total_cost_before = cost_per_customer * total_customer
roi_before = (total_revenue_before - total_cost_before) / total_cost_before

# --- SETELAH MODELING ---
# Hitung statistik rata-rata conversion rate, total spending, dan jumlah pelanggan per persona
persona_stats = df_clusterfinal.groupby('Persona').agg({
    'conversion_rate': 'mean',
    'total_spent': 'mean',
    'Persona': 'count'
}).rename(columns={'Persona': 'count'}).reset_index()

# Tentukan dua persona terbaik berdasarkan kombinasi conversion rate dan total spending
top_personas = persona_stats.sort_values(by=['conversion_rate', 'total_spent'], ascending=False).head(2)['Persona'].tolist()
target_df = df_clusterfinal[df_clusterfinal['Persona'].isin(top_personas)]

# Rata-rata conversion rate dari pelanggan yang ditarget
overall_cr_after = target_df['conversion_rate'].mean()
overall_spending_after = target_df['total_spent'].mean()

# Total revenue dan cost setelah dilakukan segmentasi dan targeting
total_revenue_after = (target_df['conversion_rate'] * target_df['total_spent']).sum()
total_cost_after = cost_per_customer * len(target_df)
roi_after = (total_revenue_after - total_cost_after) / total_cost_after

# Perubahan dan peningkatan conversion rate
cr_improvement = overall_cr_after - overall_cr_before
cr_improvement_pct = (cr_improvement / overall_cr_before) * 100

# Calculate revenue_gain, roi_gain, and cost_saving
revenue_gain = total_revenue_after - total_revenue_before  # Calculate revenue gain
roi_gain = roi_after / roi_before  # Calculate ROI gain
cost_saving = total_cost_before - total_cost_after  # Calculate cost saving


# Cetak hasil dalam format seperti business report
print("=== Business Impact Summary ===\n")
print(f"Total Customers (Before): {total_customer:,}")
print(f"üîµ Average Conversion Rate (Before Targeting): {overall_cr_before:.4f}")
print(f"Total Revenue (Before): Rp {total_revenue_before:,.0f}")
print(f"Total Cost (Before): Rp {total_cost_before:,.0f}")
print(f"ROI (Before): {roi_before:.2f}")

print(f"\nTargeted Customers (After): {len(target_df):,}")
print(f"üü¢ Average Conversion Rate (After Targeting): {overall_cr_after:.4f}")
print(f"Targeted Personas: {', '.join(top_personas)}")
print(f"Total Revenue (After): Rp {total_revenue_after:,.0f}")
print(f"Total Cost (After): Rp {total_cost_after:,.0f}")
print(f"ROI (After): {roi_after:.2f}")

print("\n=== Business Impact ===\n")
print(f"üìà Improvement Average Conversion Rate: {cr_improvement:.4f} ({cr_improvement_pct:.2f}%)")
print(f"üîº Revenue Increase: {format_rp(revenue_gain)} ({(revenue_gain / total_revenue_before) * 100:.2f}%)")
print(f"üí° ROI Improvement: {roi_gain:.2f}x")
print(f"üí∞ Cost Saving: {format_rp(cost_saving)} ({(cost_saving / total_cost_before) * 100:.2f}%)")

# Palet warna sesuai slide
custom_palette = ['#F26419', '#F6AE2D', '#2F2F2F', '#EDEDED', '#86BBD8', '#33658A']
colors = custom_palette[:2]  # Warna untuk Before dan After

metrics = {
    "Average Conversion Rate": [0.1493, 0.1684],
    "Total Revenue (Rp)": [202_537_094, 162_308_034],
    "Total Cost (Rp)": [112_000_000, 36_750_000],
    "ROI": [0.81, 3.42]
}

labels = ["Before", "After"]

def format_label(key, value):
    if "Rate" in key or key == "ROI":
        return f"{value:.2f}"
    else:
        return f"{value/1e6:.1f}M"

# Membuat barplot untuk setiap metrik
fig, axes = plt.subplots(2, 2, figsize=(14, 12))
axes = axes.flatten()

for i, (key, values) in enumerate(metrics.items()):
    sns.barplot(x=labels, y=values, palette=colors, ax=axes[i])
    axes[i].set_title(key, fontsize=13, fontweight='bold')
    axes[i].set_ylabel(key, fontsize=11)
    axes[i].set_xlabel("Campaign Phase", fontsize=11)

    for index, value in enumerate(values):
        label = format_label(key, value)
        axes[i].text(index, value + 0.02 * max(values), label, ha='center', va='bottom', fontsize=10)

plt.tight_layout()
plt.show()

# Palet warna sesuai slide
custom_palette = ['#F26419', '#F6AE2D', '#2F2F2F', '#EDEDED', '#86BBD8', '#33658A']
colors = custom_palette[:2]  # Warna untuk Before dan After

metrics = {
    "Average Conversion Rate": [0.1493, 0.1684],
    "Total Revenue (Rp)": [202_537_094, 162_308_034],
    "Total Cost (Rp)": [112_000_000, 36_750_000],
    "ROI": [0.81, 3.42]
}

labels = ["Before", "After"]

def format_label(key, value):
    if "Rate" in key or key == "ROI":
        return f"{value:.2f}"
    else:
        return f"{value/1e6:.1f}M"

# Membuat barplot untuk setiap metrik
fig, axes = plt.subplots(2, 2, figsize=(14, 10))
axes = axes.flatten()

for i, (key, values) in enumerate(metrics.items()):
    sns.barplot(x=labels, y=values, palette=colors, ax=axes[i])
    axes[i].set_title(key, fontsize=13, fontweight='bold')
    axes[i].set_ylabel(key, fontsize=11)
    axes[i].set_xlabel("Campaign Phase", fontsize=11)

    for index, value in enumerate(values):
        label = format_label(key, value)
        axes[i].text(index, value + 0.02 * max(values), label, ha='center', va='bottom', fontsize=10)

plt.tight_layout()
plt.show()

